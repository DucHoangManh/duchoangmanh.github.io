[{"content":"Go 1.22 has just been released with a bunch of new features and improvements. In this article, we will explore the new loop semantics and how they can be used to write more expressive and readable code.\n1. Loop variable is no longer be shared between iterations Previously, the loop variable was shared between iterations, from go 1.21 (experimental) and now with go 1.22, the loop variable is created anew with each iteration, effectively eliminating one of the most common foot gun in Go (for both experienced and new gophers). This is no longer needed:\nfor i := 0; i \u0026lt; 10; i++ { i := i go func () { fmt.Println(i) }() } or this\nfor i := 0; i \u0026lt; 10; i++ { go func (i int) { fmt.Println(i) }(i) } now you can do the more intuitive way:\nfor i := 0; i \u0026lt; 10; i++ { go func () { fmt.Println(i) }() } 2. Range over an integer This feature is straightforward, instead of\nfor i := 0; i \u0026lt; 10; i++ { fmt.Println(i) } now you can do\nfor i := range 10 { fmt.Println(i) } and achieve the same result, pretty neat, right?\n3. Range over a function In my humble opinion, this is one of the most exciting updates to the Go language in a long time. Now Go have a standard way to handle iterator, which is a common pattern in other languages.\nWith preceding go versions, there wasn\u0026rsquo;t a standard way to iterate through a data structure, generic is not yet available in the language so, you couldn\u0026rsquo;t write a simple iterator for different data structures.\nbufio.Scanner is an iterator through an io.Reader, where the Scan method advances to the next value. The value is returned by a Bytes method. Errors are collected and returned by an Err method. database/sql.Rows iterates through the results of a database query, where the Next method advances to the next row and the value is returned by a Scan method which can return an error. Let\u0026rsquo;s have a look at the new loop semantics in action: please note that despite this feature is available in go 1.22, it\u0026rsquo;s still experimental and may change in the future, plus you have to build your program using GOEXPERIMENT=rangefunc\n// iterate from 0 to 9 In10 := func(yield func(int) bool) { for i := range 10 { if !yield(i) { return } } } for v := range In10 { fmt.Println(v) // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } In10 is a function that takes a function yield as an argument. The yield function takes an integer and returns a boolean, whenever In10 is used, the loop body will specify the yield function, and the In10 function will call the yield function with the current value of the loop variable. You can easily see that the yield function have a signature that return a bool but the loop body itself does not return anything, this is because inside the loop body, continue or nothing will be translated to return true and break will be translated to return false. Give the user the ability to control the iteration from the loop body. The compiler will change the for over function to something that looks like this:\nInt10(func(i int) bool { fmt.Println(i) return true }) this explanation is somewhat oversimplified, the actual implementation is more complex, you can find more about it here Besides the one parameter yield function mentioned above, functions that can be ranged over can have zero or two parameters, as long as they have the following signature:\npackage iter type Seq0 func(yield func() bool) bool type Seq[V any] func(yield func(V) bool) bool type Seq2[K, V any] func(yield func(K, V) bool) bool More examples:\n// iterate over a specific range with start and end value InRange := func(start, end int) func(yield func(int) bool) { return func(yield func(int) bool) { for i := start; i \u0026lt; end; i++ { if !yield(i) { return } } } } for x := range InRange(5, 10) { fmt.Println(x) // 5, 6, 7, 8, 9 } // iterate over words in a string separated by space Words := func(s string) func(yield func(int, string) bool) { words := strings.Split(s, \u0026#34; \u0026#34;) return func(yield func(int, string) bool) { for i, word := range words { if !yield(i, word) { return } } } } for i, word := range Words(\u0026#34;sun rises in the east\u0026#34;) { fmt.Println(i, word) // 0 sun 1 rises 2 in 3 the 4 east } usually, while using some polling based library, you have to write a loop like this:\nfor { m, err := reader.ReadMessage(context.Background()) if err != nil { // handle error continue } // handle message }\tyou can leverage the new loop semantics to write a more expressive message poller:\nReaderIterator := func (reader Reader) func (func (Message, error) bool) { return func (yield func (Message, error) bool) { for { m, err := reader.ReadMessage(context.Background()) if !yield(m, err) { break } } } } for message err := range ReaderIterator(reader) { if err != nil { // handle error } // handle message } Pull iterator All the examples above are push iterators, pushing values to the yield function. But that is not always the case in the real world, sometimes you want to pull values from the iterator.\nThe Pull function from iter package converse a Seq- standard push iterator to a pull iterator. Calling Pull will start an iteration and returns a pair of functions next and stop, which return the next value from the iterator and stop it, respectively.\nInRange := func(start, end int) func(yield func(int) bool) { return func(yield func(int) bool) { for i := start; i \u0026lt; end; i++ { if !yield(i) { return } } } } next, stop := iter.Pull(InRange(5, 7)) defer stop() for value, more := next(); more; value, more = next() { fmt.Println(value) // 5, 6 } The new loop semantics surely is a great addition to the Go language as it opens the door for more idiomatic APIs with range functions.\nReferences: Go 1.22 Release Notes spec: add range over int, range over func iter: new package for iterators Go Wiki: Rangefunc Experiment ","permalink":"https://duchoangmanh.github.io/posts/technical/exploring-go-new-loop-semantics/","summary":"Go 1.22 has just been released with a bunch of new features and improvements. In this article, we will explore the new loop semantics and how they can be used to write more expressive and readable code.\n1. Loop variable is no longer be shared between iterations Previously, the loop variable was shared between iterations, from go 1.21 (experimental) and now with go 1.22, the loop variable is created anew with each iteration, effectively eliminating one of the most common foot gun in Go (for both experienced and new gophers).","title":"Go: Exploring new loop semantics"},{"content":"The significance of integration testing in assuring the reliability and seamless operation of software systems cannot be understated. This guide will help you get started with using containers for integration testing and learn how to set up and execute test cases effectively.\nLet\u0026rsquo;s consider a small example program where I use postgres as the underlying database to store product records:\ncreate table product ( id serial8 not null primary key, name varchar(100) not null, type varchar(50) not null, code varchar(50) not null, price int4 not null ); The program can create, update and list products via a repository:\ntype Product struct { ID int64 `db:\u0026#34;id\u0026#34;` Name string `db:\u0026#34;name\u0026#34;` Type string `db:\u0026#34;type\u0026#34;` Code string `db:\u0026#34;code\u0026#34;` Price int64 `db:\u0026#34;price\u0026#34;` } ... type ProductPersistenceRepository struct { db *sqlx.DB } func (r *ProductPersistenceRepository) Create(product Product) (Product, error) { created := Product{} rows, err := r.db.NamedQuery( \u0026#34;INSERT INTO product (name, type, code, price) VALUES (:name, :type, :code, :price) RETURNING *\u0026#34;, product, ) if err != nil { return created, fmt.Errorf(\u0026#34;ProductPersistenceRepository Create: %w\u0026#34;, err) } for rows.Next() { if err := rows.StructScan(\u0026amp;created); err != nil { return created, fmt.Errorf(\u0026#34;ProductPersistenceRepository Create: %w\u0026#34;, err) } } return created, nil } ... // update and list functions To test these functions against a real database, we\u0026rsquo;ll need a clean database instance.\nWith a bit of research, we can find that starting and cleaning up containerized dependencies can be done with ease by running database within a container as part of the test itself.\nI have come across some libraries that help to effectively spin up testing container, such as dockertest or testcontainer, which I will utilize in this guide. To begin, let\u0026rsquo;s write some code that runs a postgres container and returns the container address and port for later connection.\nfunc NewTestDatabase(t *testing.T) (string, string) { ctx, cancel := context.WithTimeout(context.Background(), time.Minute) defer cancel() req := testcontainers.ContainerRequest{ Image: \u0026#34;postgres:12\u0026#34;, ExposedPorts: []string{\u0026#34;5432/tcp\u0026#34;}, HostConfigModifier: func(config *container.HostConfig) { config.AutoRemove = true }, Env: map[string]string{ \u0026#34;POSTGRES_USER\u0026#34;: \u0026#34;denishoang\u0026#34;, \u0026#34;POSTGRES_PASSWORD\u0026#34;: \u0026#34;pgpassword\u0026#34;, \u0026#34;POSTGRES_DB\u0026#34;: \u0026#34;products\u0026#34;, }, WaitingFor: wait.ForListeningPort(\u0026#34;5432/tcp\u0026#34;), } postgres, err := testcontainers.GenericContainer( ctx, testcontainers.GenericContainerRequest{ ContainerRequest: req, Started: true, }, ) require.NoError(t, err) mappedPort, err := postgres.MappedPort(ctx, \u0026#34;5432\u0026#34;) require.NoError(t, err) hostIP, err := postgres.Host(ctx) require.NoError(t, err) return hostIP, mappedPort.Port() } The function above runs a postgres container like you normally do with docker cli by interacting with the docker api.\nNotice the request\u0026rsquo;s param WaitingFor: wait.ForListeningPort(\u0026quot;5432/tcp\u0026quot;), with this configuration, our tests will check if the container is listening to a specific port (5432/tcp in this case) before proceeding to the next part, makes sure that the database is ready before performing any tests. You can take a look at other wait strategies supported by testcontainer here.\nThis way, we can spin up a clean database for each test and remove it after the test is done.\nLet\u0026rsquo;s get our hands dirty with the integration test, we\u0026rsquo;ll use the address and port returned from the NewTestDatabase function to connect to the database and perform the tests.\nfunc Test_Product(t *testing.T) { host, port := NewTestDatabase(t) db, err := sqlx.Connect( \u0026#34;postgres\u0026#34;, fmt.Sprintf( \u0026#34;postgres://denishoang:pgpassword@%s:%s/products?sslmode=disable\u0026#34;, host, port, ), ) require.Nil(t, err) repo := repository.NewProductPersistenceRepository(db) t.Run( \u0026#34;test create product\u0026#34;, func(t *testing.T) { created, err := repo.Create( repository.Product{ Name: \u0026#34;cake\u0026#34;, Type: \u0026#34;food\u0026#34;, Code: \u0026#34;c1\u0026#34;, Price: 100, }, ) require.Nil(t, err) require.Equal(t, \u0026#34;cake\u0026#34;, created.Name) }, ) } try to run the test, and you\u0026rsquo;ll see in the logs that the postgres container is being created and started, and the test is being executed.\n✅ Container created: ec1c30ac431b 🐳 Starting container: ec1c30ac431b ✅ Container started: ec1c30ac431b 🚧 Waiting for container id ec1c30ac431b image: postgres:12. Waiting for: \u0026amp;{Port:5432/tcp timeout:\u0026lt;nil\u0026gt; PollInterval:100ms} then the test failed, is there something wrong?\n=== RUN Test_Product/test_create_product product_test.go:34: Error Trace:\tproduct_test.go:34 Error: Expected nil, but got: \u0026amp;fmt.wrapError{msg:\u0026#34;ProductPersistenceRepository Create: pq: relation \\\u0026#34;product\\\u0026#34; does not exist\u0026#34;, err:(*pq.Error)(0x14000442b40)} Test: Test_Product/test_create_product --- FAIL: Test_Product/test_create_product (0.00s) The error message tells us that the table product does not exist, since we are using a clean database, it\u0026rsquo;s necessary to perform some migrations before running the test.\nI\u0026rsquo;m using golang-migrate to do the migrations, this involves placing all the migration files in a directory and applying them before the tests.\n//go:embed \u0026#34;migrations\u0026#34; var EmbeddedFiles embed.FS package persistence func MigrationUp(completeDsn string) error { iofsDriver, err := iofs.New(EmbeddedFiles, \u0026#34;migrations\u0026#34;) if err != nil { return err } migrator, err := migrate.NewWithSourceInstance(\u0026#34;iofs\u0026#34;, iofsDriver, completeDsn) if err != nil { return err } return migrator.Up() } use this function after the database is ready:\nfunc NewTestDatabase(t *testing.T) (string, string) { ... err = persistence.MigrationUp( fmt.Sprintf( \u0026#34;postgres://denishoang:pgpassword@%s:%s/products?sslmode=disable\u0026#34;, hostIP, mappedPort.Port(), ), ) require.NoError(t, err) return hostIP, mappedPort.Port() } Now, the test should pass.\nHowever, there are still some things to consider: We don\u0026rsquo;t really need an entire database instance for each test as it can be resource-consuming and unnecessary.\nIdeally, we can reuse the previously created database instance and create a new database for each test.\nLet\u0026rsquo;s rewrite the NewTestDatabase function, instead of directly return the address and port of the database instance, we just create a new database instance that can be reused later.\nvar postgresContainer testcontainers.Container func StartDatabase() { ctx, cancel := context.WithTimeout(context.Background(), time.Minute) defer cancel() req := testcontainers.ContainerRequest{ Image: \u0026#34;postgres:12\u0026#34;, ExposedPorts: []string{\u0026#34;5432/tcp\u0026#34;}, HostConfigModifier: func(config *container.HostConfig) { config.AutoRemove = true }, Env: map[string]string{ \u0026#34;POSTGRES_USER\u0026#34;: \u0026#34;denishoang\u0026#34;, \u0026#34;POSTGRES_PASSWORD\u0026#34;: \u0026#34;pgpassword\u0026#34;, \u0026#34;POSTGRES_DB\u0026#34;: \u0026#34;products\u0026#34;, }, WaitingFor: wait.ForListeningPort(\u0026#34;5432/tcp\u0026#34;), } postgres, err := testcontainers.GenericContainer( ctx, testcontainers.GenericContainerRequest{ ContainerRequest: req, Started: true, }, ) if err != nil { os.Exit(1) } postgresContainer = postgres } And a function to create a new database for each test:\nfunc NewDatabase(t *testing.T) *sqlx.DB { ctx := context.Background() if postgresContainer == nil { t.Fatal(\u0026#34;postgres is not yet started\u0026#34;) } mappedPort, err := postgresContainer.MappedPort(ctx, \u0026#34;5432\u0026#34;) if err != nil { t.Fatal(\u0026#34;err get mapped port from container\u0026#34;) } hostIP, err := postgresContainer.Host(ctx) // open connection to postgres instance in order to create other databases baseDb, err := sqlx.Open( \u0026#34;postgres\u0026#34;, fmt.Sprintf( \u0026#34;postgres://denishoang:pgpassword@%s:%s/products?sslmode=disable\u0026#34;, hostIP, mappedPort.Port(), ), ) defer func() { if err := baseDb.Close(); err != nil { t.Fatal(\u0026#34;err close connection to db\u0026#34;) } }() // a naive scheme to generate random database names dbName := fmt.Sprintf(\u0026#34;%s_%d\u0026#34;, \u0026#34;products\u0026#34;, rand.Int63()) if _, err := baseDb.Exec(fmt.Sprintf(\u0026#34;CREATE DATABASE %s;\u0026#34;, dbName)); err != nil { t.Fatal(\u0026#34;err creating postgres database\u0026#34;) } connString := fmt.Sprintf( \u0026#34;postgres://denishoang:pgpassword@%s:%s/%s?sslmode=disable\u0026#34;, hostIP, mappedPort.Port(), dbName, ) // apply migrations to the newly created database if err = persistence.MigrationUp(connString); err != nil { t.Fatal(\u0026#34;err connect postgres database\u0026#34;) } // connect to new database db, err := sqlx.Open(\u0026#34;postgres\u0026#34;, connString) if err != nil { t.Fatal(\u0026#34;err connect postgres database\u0026#34;) } return db } As you can see, there is quite a bit happening here; let me explain:\nWe have started the postgres container in the StartDatabase function, and stored the container instance in a global variable. The NewDatabase function will create a new database for each test, by connecting to the postgres instance and creating a new database with a random name. It then applies migrations to the new database and returns the connection to the new database. The test that calls NewDatabase function will have its own database so, there is no need to worry about cleaning up the database after each test. Another positive aspect is that our tests can run in parallel without any issues. But we still have a problem, how to run StartDatabase before any tests?\nLuckily, go\u0026rsquo;s build in test utility provides the TestMain function, which allows us to run some setup code before or after all the tests residing in a package.\nfunc TestMain(m *testing.M) { StartDatabase() code := m.Run() // go test will decide whether the tests failed or not by exit code os.Exit(code) Put everything together by modifying our tests:\nfunc Test_Product(t *testing.T) { t.Parallel() t.Run( \u0026#34;test create product\u0026#34;, func(t *testing.T) { t.Parallel() db := NewDatabase(t) repo := repository.NewProductPersistenceRepository(db) created, err := repo.Create( repository.Product{ Name: \u0026#34;cake\u0026#34;, Type: \u0026#34;food\u0026#34;, Code: \u0026#34;c1\u0026#34;, Price: 100, }, ) require.Nil(t, err) require.Equal(t, \u0026#34;cake\u0026#34;, created.Name) }, ) t.Run( \u0026#34;test get all products\u0026#34;, func(t *testing.T) { t.Parallel() db := NewDatabase(t) repo := repository.NewProductPersistenceRepository(db) _, err := repo.Create( repository.Product{ Name: \u0026#34;cake\u0026#34;, Type: \u0026#34;food\u0026#34;, Code: \u0026#34;c1\u0026#34;, Price: 100, }, ) require.Nil(t, err) products, err := repo.GetAll() require.Nil(t, err) require.Len(t, products, 1) }, ) t.Run( \u0026#34;test update product\u0026#34;, func(t *testing.T) { t.Parallel() db := NewDatabase(t) repo := repository.NewProductPersistenceRepository(db) created, err := repo.Create( repository.Product{ Name: \u0026#34;cake\u0026#34;, Type: \u0026#34;food\u0026#34;, Code: \u0026#34;c1\u0026#34;, Price: 100, }, ) require.Nil(t, err) created.Name = \u0026#34;new cake\u0026#34; updated, err := repo.Update(created) require.Nil(t, err) require.Equal(t, \u0026#34;new cake\u0026#34;, updated.Name) }, ) } We have learned how to use container for integration testing, and how to set up and execute test cases effectively. You can see the full code here\nReferences https://golang.testcontainers.org/ ","permalink":"https://duchoangmanh.github.io/posts/technical/testing-with-test-container-go/","summary":"The significance of integration testing in assuring the reliability and seamless operation of software systems cannot be understated. This guide will help you get started with using containers for integration testing and learn how to set up and execute test cases effectively.\nLet\u0026rsquo;s consider a small example program where I use postgres as the underlying database to store product records:\ncreate table product ( id serial8 not null primary key, name varchar(100) not null, type varchar(50) not null, code varchar(50) not null, price int4 not null ); The program can create, update and list products via a repository:","title":"How to write integration tests with test container in Go"},{"content":"Reflection trong Go Reflection trong go giúp cho ta có thể theo dõi code tại thời điểm runtime, cho phép tiếp cận mã nguồn chương trình dưới dạng data có thể xử lý thay vì các lệnh có thể thực thi (một nhánh trong metaprogramming).\nReflection trong go có thể được thực hiện thông qua reflect package. Một số khả năng của reflect:\nKiểm tra thông tin của một struct (số lượng method, số lượng field, đọc struct tag\u0026hellip;) mà không cần biết trước về struct đó. Kiểm tra và cập nhật một type (slice, channel, struct, interface, pointer\u0026hellip;) mà không cần biết trước về type đó. Đổi lại những khả năng mạnh mẽ của recflect, performance và tính maintainable của code sẽ giảm, cần cân nhắc kĩ trước khi quyết định đưa vào ứng dụng.\nClear is better than clever. Reflection is never clear - Go proverb (Rob Pike)\nỨng dụng của reflect:\nCác function, method với đầu vào không rõ trước. Viết công cụ phân tích mã nguồn. Thực thi code linh hoạt (VD liệt kê các method của một struct và gọi method theo tên). Một số package, library sử dụng reflection: fmt, encoding/json, gorm, sqlx\u0026hellip;\nCác khái niệm quan trọng Có hai type quan trọng trong reflect package: reflect.Type và reflect.Value, mọi biến trong một chương trình có thể được thể hiện bởi một cặp Value và Type. reflect.Type và reflect.Value như tên gọi chứa các thông tin tương ứng về type và value của biến đang xem xét, đi kèm các utilitiy funtion và method để thao tác với data. Các giá trị này của một biến x bất kì có thể được lấy bằng reflect.ValueOf(x) và reflect.TypeOf(x):\ntype Person struct { Name string Age int } p := Person{ Name: \u0026#34;Duc\u0026#34;, Age: 10, } pp := \u0026amp;p o := []int{1, 2, 3} s := \u0026#34;reflect in go\u0026#34; fmt.Printf(\u0026#34;(%v, %v)\\n\u0026#34;, reflect.ValueOf(p), reflect.TypeOf(p)) fmt.Printf(\u0026#34;(%v, %v)\\n\u0026#34;, reflect.ValueOf(pp), reflect.TypeOf(pp)) fmt.Printf(\u0026#34;(%v, %v)\\n\u0026#34;, reflect.ValueOf(o), reflect.TypeOf(o)) fmt.Printf(\u0026#34;(%v, %v)\\n\u0026#34;, reflect.ValueOf(s), reflect.TypeOf(s)) Kết quả:\n({Duc 10}, main.Person) (\u0026amp;{Duc 10}, *main.Person) ([1 2 3], []int) (reflect in go, string) Ngoài ra ta cũng có thể đọc được thêm một số thông tin quan trọng khác như reflect.Kind - chứa thông tin cụ thể hơn về kiểu của một biến, có thể truy cập bằng Value.Kind() hoặc Type.Kind():\nfmt.Printf(\u0026#34;(%v, %v)\\n\u0026#34;, reflect.TypeOf(p), reflect.ValueOf(p).Kind()) fmt.Printf(\u0026#34;(%v, %v)\\n\u0026#34;, reflect.TypeOf(pp), reflect.ValueOf(pp).Kind()) fmt.Printf(\u0026#34;(%v, %v)\\n\u0026#34;, reflect.TypeOf(o), reflect.ValueOf(o).Kind()) fmt.Printf(\u0026#34;(%v, %v)\\n\u0026#34;, reflect.TypeOf(s), reflect.ValueOf(s).Kind()) Kết quả:\n(main.Person, struct) (*main.Person, ptr) ([]int, slice) (string, string) Parse url query với reflection Xét bài toán cần viết một hàm nhận vào một *http.Request và một struct sau đó fill dữ liệu từ URL query vào struct đó:\ntype Person struct { Name string Age int } func ParseQuery(r *http.Request, p *Person) (err error) { q := r.URL.Query() p.Name = q.Get(\u0026#34;name\u0026#34;) p.Age, err = strconv.Atoi(q.Get(\u0026#34;age\u0026#34;)) return err } func TestParseQuery(t *testing.T) { req, _ := http.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;/root?name=Duc\u0026amp;age=10\u0026#34;, nil) var d Person err := Parse(req, \u0026amp;d) if err != nil { t.Error(err.Error()) } fmt.Println(d) // {Duc 10} } Một ví dụ khá cơ bản và thường gặp phải không? Tuy nhiên cách làm này sẽ cần phải lặp lại code khá nhiều.\nVậy thay vì biết trước struct được truyền vào là Person thì ta có thể truyền một struct bất kì với các field có tên ứng với các query có thể gặp mà vẫn đạt được kết quả tương tự hay không? Với reflect thì hoàn toàn có thể.\nÝ tưởng là có thể dùng reflect để đọc thông tin của struct bất kỳ được truyền vào, duyệt qua lần lượt các field, và kiểm tra xem trong URL có query nào tương ứng với field đang xét hay không, nếu có thì đọc giá trị của query vào field.\nBắt tay vào code Tổng quan của chương trình có thể được thể hiện như sau:\nfunc Parse(r *http.Request, dest any) (err error) { v := reflect.ValueOf(dest) q := r.URL.Query() if v.Kind() != reflect.Ptr || v.Elem().Kind() != reflect.Struct { return fmt.Errorf(\u0026#34;dest must be a pointer to a struct\u0026#34;) } v = v.Elem() t := v.Type() for i := 0; i \u0026lt; v.NumField(); i++ { fVal := v.Field(i) fType := t.Field(i) fName := strings.ToLower(fType.Name) err = parse(q.Get(fName), fVal) if err != nil { return fmt.Errorf(\u0026#34;parse %w\u0026#34;, err) } } return nil } func parse(stringVal string, destVal reflect.Value) (err error) { // xử lý cụ thể cho từng field } Lưu ý là bắt buộc đầu vào của hàm phải là một con trỏ tới struct thì reflect mới có thể thay đổi được struct đó, ta có thể kiểm tra điều kiện này với v.Kind() == reflect.Ptr và v.Elem().Kind() == reflect.Struct - Vì ta expect giá trị truyền vào là con trỏ (tương ứng reflect.Ptr nên cần gọi Elem() để lấy ra giá trị thực ở sau con trỏ đó) Sau khi đã có được Type và Value của struct đầu vào rồi, ta sẽ tiến hành duyệt qua từng field và xử lý cụ thể ở trong hàm parse\nfunc parse(stringVal string, destVal reflect.Value) (err error) { if stringVal == \u0026#34;\u0026#34; { // bỏ qua nếu như không có query tương ứng với field này return nil } if !destVal.CanSet() { return fmt.Errorf(\u0026#34;field unexported or cannot set value\u0026#34;) } k := destVal.Kind() switch { case k == reflect.String: err = parseString(stringVal, destVal) case k \u0026gt;= reflect.Int \u0026amp;\u0026amp; k \u0026lt;= reflect.Int64: err = parseInt(stringVal, destVal) default: err = fmt.Errorf(\u0026#34;type not supported: %v\u0026#34;, destVal.Type()) return err } Giải thích: Trong hàm này ta sẽ kiểm tra Kind của từng field và với mỗi kind đó sẽ có hàm cụ thể để xử lý giúp cho code clear hơn. Trick nhỏ là thay vì kiểm tra với từng kiểu int, int8\u0026hellip; thì có thể viết k \u0026gt;= reflect.Int \u0026amp;\u0026amp; k \u0026lt;= reflect.Int64 do trong mã nguồn của reflect, các Kind có thể có của biến được viết dưới dạng:\nconst ( Invalid Kind = iota Bool Int Int8 Int16 Int32 Int64 ... ) Tương tự với uint và float.\nLưu ý quan trọng: reflect không thể cập nhật unexported field, nên cần kiểm tra trước với CanSet() (tương ứng với CanAddr() == true và field exported). hoặc có thể kiểm tra với CanInterface()\nViết hàm parse đối với từng Kind:\nfunc parseString(in string, dest reflect.Value) error { dest.SetString(in) return nil } func parseInt(in string, dest reflect.Value) error { intVal, err := strconv.ParseInt(in, 10, 0) if err != nil { return fmt.Errorf(\u0026#34;parseInt %w\u0026#34;, err) } dest.SetInt(intVal) return nil } Tiến hành chạy thử chương trình:\ntype Person struct { Name string Age int } func TestQueryParser(t *testing.T) { req, _ := http.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;/root?name=Duc\u0026amp;age=10\u0026#34;, nil) var d Person err := Parse(req, \u0026amp;d) if err != nil { t.Error(err.Error()) } fmt.Println(d) // {Duc 10} } It works!\nThế còn slice thì sao? Đầu vào:\ntype Person struct { ... IDs []int } Expect với URL query có dạng ?ids=1,2,3, sau khi parse thì field IDs sẽ có giá trị []int{1,2,3}.\nThêm case đối với Kind == reflect.Slice ở hàm parse\nfunc parse(stringVal string, destVal reflect.Value) (err error) { ... case k == reflect.Slice: err = parseSlice(stringVal, destVal) ... } func parseSlice(in string, dest reflect.Value) error { parts := strings.Split(in, \u0026#34;,\u0026#34;) sliceType := dest.Type().Elem() // lấy type của phần tử strong slice sliceLen := len(parts) sliceVal := reflect.MakeSlice(reflect.SliceOf(sliceType), sliceLen, sliceLen) // make slice tương ứng for i := 0; i \u0026lt; sliceLen; i++ { // xử lý cho từng phần tử trong slice tương tự như struct ở trên err := parse(parts[i], sliceVal.Index(i)) // parse từng phần tử trong slice như đã làm với int và string if err != nil { return fmt.Errorf(\u0026#34;parseSlice %w\u0026#34;, err) } } dest.Set(sliceVal) return nil } Để chuyển từ URL query sang slice, ta cần kiểm tra xem ở struct đích slice có kiểu dữ liệu gì và make slice tương ứng, những công việc sau đó không khác gì so với xử lý struct ở phần trên.\nChạy thử với slice:\ntype Person struct { Name string Age int IDs []int } func TestQueryParser(t *testing.T) { req, _ := http.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;/root?ids=1,2,3\u0026#34;, nil) var d Person err := Parse(req, \u0026amp;d) if err != nil { t.Error(err.Error()) } fmt.Println(d.IDs) // [1 2 3] } Parse query linh động với struct tag Ở phiên bản hiện tại, chương trình dựa trên tên của các field trong struct để từ đó lấy ra query tương ứng. Để chương trình được flexible hơn, có thể dùng struct tag để chỉ định query tương ứng với từng field. Ví dụ\ntype Person struct { Name string `query:\u0026#34;title\u0026#34;` ... } Với sự hiện diện của tag query, field Name sẽ được parse từ query title, các field không có tag query thì behavior vẫn không thay đổi.\nBổ sung thêm phần đọc struct tag cho hàm Parse:\nfunc Parse(r *http.Request, dest any) (err error) { v := reflect.ValueOf(dest) q := r.URL.Query() if !v.IsValid() || v.Kind() != reflect.Ptr || v.Elem().Kind() != reflect.Struct { return fmt.Errorf(\u0026#34;dest must be a pointer to not nil struct\u0026#34;) } v = v.Elem() t := v.Type() for i := 0; i \u0026lt; v.NumField(); i++ { fVal := v.Field(i) fType := t.Field(i) fName := strings.ToLower(fType.Name) if queryTag := fType.Tag.Get(\u0026#34;query\u0026#34;); queryTag != \u0026#34;\u0026#34; { // kiểm tra field có tag query hay không fName = queryTag } err = parse(q.Get(fName), fVal) if err != nil { return fmt.Errorf(\u0026#34;parse %w\u0026#34;, err) } } return nil } Và chạy thử:\ntype Person struct { Name string `query:\u0026#34;title\u0026#34;` Age int IDs []int } func TestQueryParser(t *testing.T) { req, _ := http.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;/root?name=Duc\u0026amp;age=10\u0026amp;title=Gopher\u0026#34;, nil) var d Person err := Parse(req, \u0026amp;d) if err != nil { t.Error(err.Error()) } fmt.Println(d) // {Gopher 10 []} } Custom parse với interface Đến phiên bản hiện tại, parser đã có thể đạp ứng được các kiều dữ liệu cơ bản trong đa số trường hợp, nhưng chưa thể hoạt động được với các kiểu dữ liệu tự định nghĩa. Ví dụ với field Name, thay vì đơn thuần là một string, có thể là struct dạng:\ntype Name struct { First string Last string } type Person struct { Name Name Age int IDs []int } Expect với URL query có dạng ?name=duc_hoang thì sau khi parse query, giá trị của Person.Name sẽ là Name{First:\u0026quot;duc\u0026quot;,Last:\u0026quot;hoang\u0026quot;}.\nMột lưu ý khi viết các hàm hay thư viện với reflect, thì nên hạn chế việc expose cho client phải thao tác với reflect để đơn giản hóa việc sử dụng hàm hay thư viện đó. Trong trường hợp này, có thể dùng một interface để biểu thị kiểu dữ liệu tự định nghĩa có thể parse được, khi Parse và field đích implement interface này thì có thể dùng hàm tương ứng để xử lý field.\ntype QueryParser interface { QueryParse(string) error } Implement QueryParser interface cho kiểu Name:\nfunc (n *Name) QueryParse(in string) error { parts := strings.Split(in, \u0026#34;_\u0026#34;) if len(parts) != 2 { return fmt.Errorf(\u0026#34;invalid input\u0026#34;) } n.First = parts[0] n.Last = parts[1] return nil } Lưu ý là cần implement đối với pointer receiver để method có thể thay đổi giá trị của receiver.\nTiến hành handle trong function parse:\nfunc parse(stringVal string, destVal reflect.Value) (err error) { ... default: err = parseDefault(stringVal, destVal) // chuyển Kind mặc định ra handle riêng để đảm bảo code được clear và dễ maintain } return err } func parseDefault(in string, dest reflect.Value) error { if dest.Kind() != reflect.Ptr { dest = dest.Addr() // lấy con trỏ của dest nếu dest đang không phải con trỏ } else if dest.IsNil() { dest.Set(reflect.New(dest.Type().Elem())) // khởi taọ nếu dest là con trỏ nil } if queryParser, ok := dest.Interface().(QueryParser); ok { return queryParser.QueryParse(in) // parser giá trị từ query vào dest } return fmt.Errorf(\u0026#34;type not supported: %s\u0026#34;, dest.Type().Kind()) } Trong hàm parseDefault, giá trị đích sẽ luôn được chuyển sang kiểu con trỏ trước khi xác định xem nó có implement QueryParser hay không.\nTrong trường hợp giá trị đích đã là con trỏ rồi, cần kiểm tra xem có phải nil hay không, nếu là nil thì cần phải khởi tạo trước khi gọi method.\nVà chạy thử:\ntype Name struct { First string Last string } func (n *Name) QueryParse(in string) error { parts := strings.Split(in, \u0026#34;_\u0026#34;) if len(parts) != 2 { return fmt.Errorf(\u0026#34;invalid input\u0026#34;) } n.First = parts[0] n.Last = parts[1] return nil } type Person struct { Name Name Age int IDs []int } func TestQueryParser(t *testing.T) { req, _ := http.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;/root?name=duc_hoang\u0026#34;, nil) var d Person err := Parse(req, \u0026amp;d) if err != nil { t.Error(err.Error()) } fmt.Printf(\u0026#34;(%s, %s)\u0026#34;, d.Name.First, d.Name.Last) // (duc, hoang) } Source code trong bài: https://github.com/DucHoangManh/queryparser\n","permalink":"https://duchoangmanh.github.io/posts/technical/go-reflection-qua-vi-du/","summary":"Reflection trong Go Reflection trong go giúp cho ta có thể theo dõi code tại thời điểm runtime, cho phép tiếp cận mã nguồn chương trình dưới dạng data có thể xử lý thay vì các lệnh có thể thực thi (một nhánh trong metaprogramming).\nReflection trong go có thể được thực hiện thông qua reflect package. Một số khả năng của reflect:\nKiểm tra thông tin của một struct (số lượng method, số lượng field, đọc struct tag\u0026hellip;) mà không cần biết trước về struct đó.","title":"Go: Giới thiệu về reflection qua ví dụ"},{"content":"1. Kiểm tra sự xuất hiện của một phần tử trong slice Type parameter hay generic là một tính năng mới xuất hiện từ phiên bản 1.18 của Go. Với generic, ta có thể viết các hàm hoặc type có thể dùng được cho nhiều kiểu dữ liệu đầu vào khác nhau mà không cần phải lặp lại code nhiều lần.\nHãy bắt đầu với một ví dụ đơn giản và phổ biến: Kiểm tra xem string có xuất hiện trong slice hay không\nfunc StringSliceContains(ss []string, match string) bool { for _, s := range ss { if s == match { return true } } return false } Rõ ràng là trong quá trình sử dụng thực tế, ta sẽ gặp các usecase tương tự với các kiểu dữ liệu khác. Trước khi có generic, việc phổ biến nhất sẽ là viết riêng các hàm cụ thể cho từng kiểu dữ liệu IntSliceContains(), Int64SliceContains()\u0026hellip; bên cạnh việc sử dụng code generation hay reflection.\nCó thể thấy các hàm này đều lặp lại một logic giống nhau, chỉ khác ở kiểu dữ liệu đầu vào, với generic, ta hoàn toàn có thể rút gọn lại các hàm này lại thành một, rất gọn và dễ dàng bảo trì về sau:\nfunc SliceContains[T comparable](ss []T, match T) bool { for _, s := range ss { if s == match { return true } } return false } Giải thích:\n[T comparable] được gọi là type parameter và có thể sử dụng được với một func hoặc một type, trong trường hợp này ám chỉ việc hàm SliceContains có thể nhận vào đầu vào kiểu T thỏa mãn ràng buộc comparable.\nRàng buộc ở đây là một interface mà T cần thỏa mãn, interface này có thể chứa method signature thường thấy hoặc tập hợp các type bất kì, xem thêm package constraints.\nTa hoàn toàn có thể định nghĩa constraints cùa riêng mình.\ntype MyConstraint interface { ~int | ~string } func SliceContains[T MyConstraint](ss []T, match T) bool { for _, s := range ss { if s == match { return true } } return false } Như ví dụ trên đây, T cần là int hoặc string, toán tử ~ tức ràng buộc thỏa mãn với cả các kiểu được định nghĩa từ int hoặc string (ví dụ type Name string, type Age int)\nfunc TestSliceContains(t *testing.T) { intSlice := []int{4, 5, 6} stringSlice := []string{\u0026#34;a\u0026#34;, \u0026#34;abb\u0026#34;, \u0026#34;c\u0026#34;} fmt.Println(SliceContains(intSlice, 5)) // true fmt.Println(SliceContains(stringSlice, \u0026#34;c\u0026#34;)) // true } Có thể thấy là khi gọi hàm không cần chỉ rõ ra T là kiểu gì mà chỉ cần truyền các parameter vào, go có thể tự hiểu và thực thi đúng hàm mà ta mong muốn, SliceContains[int](intSlice, 5) cũng tương đương với SliceContains(intSlice, 5).\nTa cũng có thể viết một hàm kiểm tra phần tử có thuộc slice hay không mà không có ràng buộc, thay vào đó, truyền vào một funcion equalFunc để sử dụng thay cho toán tử ==:\nfunc SliceContainsWithEqual[T any](ss []T, match T, equalFunc func(T, T) bool) bool { for _, s := range ss { if equalFunc(s, match) { return true } } return false } 2. Generic wrapper cho container/heap Trong go, khi cần sử dụng heap, ta có thể sử dụng package container/heap và implement heap.Interface cho kiểu dữ liệu muốn sử dụng.\nVí dụ một min heap cho kiểu int từ trong document của container/heap:\ntype IntHeap []int func (h IntHeap) Len() int { return len(h) } func (h IntHeap) Less(i, j int) bool { return h[i] \u0026lt; h[j] } func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *IntHeap) Push(x any) { // Push and Pop use pointer receivers because they modify the slice\u0026#39;s length, // not just its contents. *h = append(*h, x.(int)) } func (h *IntHeap) Pop() any { old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x } Trong nhiều trường hợp, ta chỉ quan tâm tới kiểu dữ liệu và method Less, còn cách triền khai tương tự như ví dụ trên.\nCó thể dùng type parameter để đơn giản hóa việc sử dụng heap như sau:\ntype Heap[T any] struct { data []T lessFunc func(a, b T) bool } func (b *Heap[T]) Len() int { return len(b.data) } func (b *Heap[T]) Less(i, j int) bool { return b.lessFunc(b.data[i], b.data[j]) } func (b *Heap[T]) Swap(i, j int) { tmp := b.data[i] b.data[i] = b.data[j] b.data[j] = tmp } func (b *Heap[T]) Push(x any) { b.data = append(b.data, x.(T)) } func (b *Heap[T]) Pop() any { old := b.data oldLen := len(old) res := old[oldLen-1] b.data = b.data[:oldLen-1] return res } func New[T any](lessFunc func(T, T) bool) *Heap[T] { h := \u0026amp;Heap[T]{ lessFunc: lessFunc, } heap.Init(h) return h } Type parameter cũng có thể sử dụng với type như trong ví dụ này. Mấu chốt trong cách triển khai này chính là lưu lại lessFunc trong struct Heap, do ta không thể thay đổi method Less tại runtime, thay vào đó Less sẽ gọi vào hàm được lưu trong receiver.\nTuy nhiên có thể thấy rằng kiểu của các method như Push hay Pop lại là any và để đảm bảo implement heap.Interface, ta không thể sửa signature của các method này. Ngoài ra, việc gọi trực tiếp *Heap.Pop thay vì heap.Pop(*Heap), và *Heap.Push(T) thay vì heap.Push(*Heap, T) sẽ gây ra kết quả sai, thay vào đó nên tránh cho phép gọi trực tiếp các method này. Ta sẽ wrap type mà implement heap interface trong một public Type mà sẽ nhận và trả về kết quả mong muốn:\nChuyển triển khai trên thành một unexported struct với tên base:\ntype base[T any] struct { data []T lessFunc func(a, b T) bool } func (b *base[T]) Len() int { return len(b.data) } func (b *base[T]) Less(i, j int) bool { return b.lessFunc(b.data[i], b.data[j]) } func (b *base[T]) Swap(i, j int) { tmp := b.data[i] b.data[i] = b.data[j] b.data[j] = tmp } func (b *base[T]) Push(x any) { b.data = append(b.data, x.(T)) } func (b *base[T]) Pop() any { old := b.data oldLen := len(old) res := old[oldLen-1] b.data = b.data[:oldLen-1] return res } Và viết thêm một genetic type với các method mà ta mong muốn:\ntype Heap[T any] struct { base *base[T] } func New[T any](lessFunc func(T, T) bool) *Heap[T] { b := \u0026amp;base[T]{ lessFunc: lessFunc, } heap.Init(b) return \u0026amp;Heap[T]{base: b} } func (h *Heap[T]) Push(t T) { heap.Push(h.base, t) } func (h *Heap[T]) Pop() T { if h.Len() == 0 { // thêm validate cho Pop var t T return t } return heap.Pop(h.base).(T) // chuyển đổi kiểu trả về cho đúng } func (h *Heap[T]) Len() int { return h.base.Len() } Chạy thử:\nfunc TestGenericHeap(t *testing.T) { data := []int{0, 5, 4, 2, -5, 8, 9, -10} lessFunc := func(i, j int) bool { return j-i \u0026gt; 0 } heap := New(lessFunc) for _, v := range data { heap.Push(v) } for heap.Len() \u0026gt; 0 { fmt.Print(heap.Pop(), \u0026#34; \u0026#34;) } } Kết quả:\n-10 -5 0 2 4 5 8 9 Clear hơn khá nhiều phải không? Có thể xem code đầy đủ tại đây\n3. Khi nào dùng type parameter? Khi dùng type parameter chỉ để gọi method của constraints thì không nên dùng type parameter mà nên dùng hàm bình thường nhận vào interface. thay vì func foo[T io.Writer](w T) { ... w.Write... ... } tốt hơn là\nfunc foo(w io.Writer) { ... w.Write... ... } như cách mà nó vẫn được viết từ trước khi go có generic.\nVà trong nhiều trường hợp, việc sử dụng type parameter có thể ảnh hưởng nhiều đến tính dễ bảo trì của code, hãy cân nhắc sử dụng các phương pháp khác đã nêu ở phần 1. Hãy nhớ là go developer vẫn sống (khá) tốt trong một thời gian dài mà không có generic (◍•ᴗ•◍)👍. ","permalink":"https://duchoangmanh.github.io/posts/technical/go-gioi-thieu-type-parameter-qua-vi-du/","summary":"1. Kiểm tra sự xuất hiện của một phần tử trong slice Type parameter hay generic là một tính năng mới xuất hiện từ phiên bản 1.18 của Go. Với generic, ta có thể viết các hàm hoặc type có thể dùng được cho nhiều kiểu dữ liệu đầu vào khác nhau mà không cần phải lặp lại code nhiều lần.\nHãy bắt đầu với một ví dụ đơn giản và phổ biến: Kiểm tra xem string có xuất hiện trong slice hay không","title":"Go: Giới thiệu về type parameter (generic) qua ví dụ"},{"content":"Some Go tips (maybe some dark side too) and notes for writing better code.\n1. Efficiently converse between string and byte slice Gain some performance with the price of maintainability. Using the unsafe package is not advised but we can use it to efficiently converse between a string and byte slice. Use at your own risk.\nbyte slice to string func String(b []byte) (s string) { if len(b) == 0 { return \u0026#34;\u0026#34; } return *(*string)(unsafe.Pointer(\u0026amp;b)) } string to byte slice // mutate the returned slice can cause undefined behavior func ByteSlice(s string) []byte { var b []byte hdr := (*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;b)) hdr.Data = (*reflect.StringHeader)(unsafe.Pointer(\u0026amp;s)).Data hdr.Cap = len(s) hdr.Len = len(s) return b } 2. Change function return value with defer Normally, if we change the returned value with defer, it will not works\nfunc someFunc() int { i := 1 defer func() { i = 2 }() return i } func main() { fmt.Println(someFunc()) // 1 } But with a named return value, defer can change return value of a function\nfunc someFunc() (i int) { i = 1 defer func() { i = 2 }() return i } func main() { fmt.Println(someFunc()) // 2 } 3. Mutate a slice the right way Slice has a pointer to a backing array do not mean that it can be mutated by value\nLet\u0026rsquo;s look at the slice header from reflect package (a runtime representation of a slice but the idea is the same):\ntype SliceHeader struct { Data uintptr // pointer to the underlying array but can change when slice grows Len int // not safe for mutating via value Cap int // not safe for mutating via value } Don\u0026rsquo;t\nfunc main() { var s []int mutate(s) fmt.Println(s) // [] } func mutate(s []int) { s = append(s, 1) } Do\nfunc main() { var s []int mutate(\u0026amp;s) fmt.Println(s) // [1] } func mutate(s *[]int) { *s = append(*s, 1) } 4. Check if the any have desired method Sometimes we want to check if a variable of any type has some methods or not, consider using an anonymous interface\nimport \u0026#34;fmt\u0026#34; type Me int func (m Me) Pr() { fmt.Println(m) } func main() { var m any m = Me(1) if callable, ok := m.(interface { Pr() }); ok { // some action when the method exist } } If the interface is used more than once, better define a proper interface.\n5. Allocate memory for slices in advance We should use the third parameter when making a slice to allocate some memory for that slice to reduce slice grow.\nsomeSlice := make([]int, 0, size) And keep in mind that even if we use a slice with a part of an underlying array, the rest of that array may live in memory much longer than needed, consider copying to a new slice if necessary.\nPre-allocating can be used for maps too!\nsomeMap:= make(map[int]int, size) 6. Efficient String concatenation There\u0026rsquo;s some way to do string concatenation like use + or fmt package\nresult := \u0026#34;hello\u0026#34; + \u0026#34;world\u0026#34; // clean but remember that strings in go are immutable, so not very efficient result := fmt.Sprintf(\u0026#34;%s %s\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;) // use reflect under the hood Instead, consider strings.Builder\nvar b strings.Builder b.WriteString(\u0026#34;hello\u0026#34;) b.WriteString(\u0026#34;world\u0026#34;) result := b.String() In most cases, the difference can be neglected, but if we are doing heavy string concatenation like in a for loop, better use strings.Builder\n7. Channel special behaviors They are well known:\nA send to a nil channel blocks forever A receive from a nil channel blocks forever A send to a closed channel panics A receive from a closed channel returns the zero value immediately 8. Do not copy a sync type sync types shouldn’t be copied. This rule applies to:\nsync.Cond sync.Map sync.Mutex sync.RWMutex sync.Once sync.Pool sync.WaitGroup 9. io.Reader can only be read once Most type that implements the io.Reader interface (os.File, http.Request.Body...) behave like a stream and can only be read once. We can work around this with io.TeeReader that duplicate the stream, but in most case just avoid read an io.Reader a second time.\n10. Always close transient resource Remember to close transient resources to avoid memory leaks. Includes http.Response.Body, sql.Rows, os.File and more\n","permalink":"https://duchoangmanh.github.io/posts/technical/go-tips-and-optimization-notes/","summary":"Some Go tips (maybe some dark side too) and notes for writing better code.\n1. Efficiently converse between string and byte slice Gain some performance with the price of maintainability. Using the unsafe package is not advised but we can use it to efficiently converse between a string and byte slice. Use at your own risk.\nbyte slice to string func String(b []byte) (s string) { if len(b) == 0 { return \u0026#34;\u0026#34; } return *(*string)(unsafe.","title":"Go tips and optimization notes"},{"content":"This post contains my notes while implement caneweb - a gin-like minimal web framework/router after reading the first section of 7 days golang by geektutu (https://github.com/geektutu/7days-golang).\nHow standard net/http package handle request? First, let\u0026rsquo;s look at a sample written with net/http package:\nfunc main() { http.HandleFunc(\u0026#34;/\u0026#34;, handler) http.HandleFunc(\u0026#34;/post\u0026#34;, getAllPost) log.Fatal(http.ListenAndServe(\u0026#34;localhost:8000\u0026#34;, nil)) } func handler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;URL.Path = %q\\n\u0026#34;, r.URL.Path) } This piece of code binds two endpoints with the corresponding handler function, and starts a web server at port 8000, terminates the server if some errors are returned.\nAll http handlers must implement the handler interface, and we can use multiple handlers to handle a single request by passing the parameters around:\ntype Handler interface { ServeHTTP(ResponseWriter, *Request) } The standard library package does provide basic functions to create a web server including monitor port, static routing, request parsing\u0026hellip; Some other functions need to be implemented when necessary:\nDynamic routing: routing with rules like post/:id, post/*,\u0026hellip; or using regular expression. Middleware: By passing around the request, and response between multiple functions to change the result. Group requests: Group endpoints into a cluster that share some commons. Validate requests. \u0026hellip; Create the static-routing version of the framework First, we need to design a struct that represents the state of the current request data and have methods to easily work with requests.\nWhy encapsulate response and request into a single struct? Reduce the complexity of the handler, a user no longer need to care about which data resides in request, or responseWriter Easier to create a response and less error-prone, reduce repetitive For example, in order to write the response for a request, instead of\nobj = map[string]interface{}{ \u0026#34;title\u0026#34;: \u0026#34;my first blog post\u0026#34;, \u0026#34;read_time\u0026#34;: \u0026#34;5\u0026#34;, } w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) w.WriteHeader(http.StatusOK) encoder := json.NewEncoder(w) if err := encoder.Encode(obj); err != nil { http.Error(w, err.Error(), 500) } We can achive the same result in a simpler and clearer way:\nc.JSON(http.StatusOK, cane.Map{ \u0026#34;title\u0026#34;: \u0026#34;my first blog post\u0026#34;, \u0026#34;read_time\u0026#34;: 5, }) ctx.go\npackage cane import \u0026#34;net/http\u0026#34; type Ctx struct { // origin objects Writer http.ResponseWriter Req *http.Request // request data Path string Method string // response data StatusCode int } // newCtx create new Ctx with original data func newCtx(w http.ResponseWriter, r *http.Request) *Ctx { return \u0026amp;Ctx{ Writer: w, Req: r, Path: r.URL.Path, Method: r.Method, } } Add some functions to work with request and reponse morre efficiently:\n// responseWriter func (c *Ctx) SetHeader(key, value string) { c.Writer.Header().Set(key, value) } func (c *Ctx) Status(code int) { c.StatusCode = code c.Writer.WriteHeader(code) } func (c *Ctx) String(code int, formatString string, values ...interface{}) { c.SetHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/plain\u0026#34;) c.Status(code) _, err := fmt.Fprintf(c.Writer, formatString, values...) if err != nil { http.Error(c.Writer, err.Error(), http.StatusInternalServerError) } } func (c *Ctx) JSON(code int, data interface{}) { c.SetHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) c.Status(code) encoder := json.NewEncoder(c.Writer) err := encoder.Encode(data) if err != nil { http.Error(c.Writer, err.Error(), http.StatusInternalServerError) } } func (c *Ctx) HTML(code int, html string) { c.SetHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/html\u0026#34;) c.Status(code) _, err := c.Writer.Write([]byte(html)) if err != nil { http.Error(c.Writer, err.Error(), http.StatusInternalServerError) } } // request func (c *Ctx) FormValue(key string) string { return c.Req.FormValue(key) } func (c *Ctx) Query(key string) string { return c.Req.URL.Query().Get(key) } Our handler interface should look like this:\ntype Handler interface { Serve(c *Ctx) } Instead of creating a struct for each handler, we can use an adapter to use a function for a simple task, like in the standard net/http package:\ntype HandleFunc func(c *Ctx) func (f HandleFunc) Serve(c *Ctx) { f(c) } The static-routing router Now, we need an object to keep all our static routing configurations and decide which handler to use with each URL and method a.k.a router In this first version of the web framework, I simply use a map to represent the router with static routing:\nrouter.go\ntype router struct { handlers map[string]Handler } func newRouter() *router { return \u0026amp;router{ handlers: make(map[string]Handler), } } // create route from method and path func getRoute(method, path string) (route string) { var builder strings.Builder fmt.Fprintf(\u0026amp;builder, \u0026#34;%s%s%s\u0026#34;, method, \u0026#34;-\u0026#34;, path) route = builder.String() return } // add a new route to the router func (r *router) addRoute(method, path string, handler Handler) { log.Printf(\u0026#34;add route %s %s\u0026#34;, method, path) route := getRoute(method, path) r.handlers[route] = handler } //route request to appropriate handler, error code if no handler found func (r *router) handle(c *Ctx) { route := getRoute(c.Method, c.Path) if handler, ok := r.handlers[route]; ok { handler.Serve(c) } else { c.Writer.WriteHeader(http.StatusNotFound) c.String(http.StatusNotFound, \u0026#34;No route found\u0026#34;) } } Create the interface of caneweb Lastly, we need a layer for the user to work with the web framework, by hiding the internal implementation of the router and such.\ntype Engine struct { router *router } // constructor of cane web framework func New() *Engine { return \u0026amp;Engine{ router: newRouter(), } } func (e *Engine) addRoute(method, pattern string, handler Handler) { e.router.addRoute(method, pattern, handler) } // define some simple operations func (e *Engine) GET(pattern string, handler Handler) { e.addRoute(http.MethodGet, pattern, handler) } func (e *Engine) POST(pattern string, handler Handler) { e.addRoute(http.MethodPost, pattern, handler) } // implement the standard package Handler interface // and transform incoming request to our handler func (e *Engine) ServeHTTP(w http.ResponseWriter, r *http.Request) { ctx := newCtx(w, r) e.router.handle(ctx) } func (e *Engine) Run(addr string) error { return http.ListenAndServe(addr, e) } Create a simple server with the framework main.go\npackage main import ( \u0026#34;caneweb/cane\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { server := cane.New() server.GET(\u0026#34;/hello\u0026#34;, cane.HandleFunc(hello)) server.POST(\u0026#34;/post\u0026#34;, cane.HandleFunc(createPost)) log.Fatal(server.Run(\u0026#34;:5445\u0026#34;)) } func hello(c *cane.Ctx) { c.String(http.StatusOK, \u0026#34;hello %s\u0026#34;, c.Query(\u0026#34;name\u0026#34;)) } func createPost(c *cane.Ctx) { title := c.FormValue(\u0026#34;title\u0026#34;) desc := c.FormValue(\u0026#34;desc\u0026#34;) c.JSON(http.StatusOK, cane.Map{ \u0026#34;post_title\u0026#34;: title, \u0026#34;description\u0026#34;: desc, }) } Send requests to the web server with curl.\ncurl \u0026#34;127.0.0.1:5445/hello?name=duchm\u0026#34; hello duchm curl \u0026#34;http://localhost:5445/post\u0026#34; -X POST -d \u0026#39;title=\u0026#34;first post\u0026#34;\u0026amp;desc=\u0026#34;rainny day\u0026#34;\u0026#39; {\u0026#34;description\u0026#34;:\u0026#34;\\\u0026#34;rainny day\\\u0026#34;\u0026#34;,\u0026#34;post_title\u0026#34;:\u0026#34;\\\u0026#34;first post\\\u0026#34;\u0026#34;} curl \u0026#34;127.0.0.1:5445/any\u0026#34; No route found That\u0026rsquo;s it, after this, we have implemented the prototype version of caneweb framework in go. Currently, the framework does nothing more than the standard net/http package but worry not, some other nice features will be added in the next versions.\nSee the source code at https://github.com/DucHoangManh/caneweb\n","permalink":"https://duchoangmanh.github.io/posts/technical/create-a-web-framework-in-go/","summary":"This post contains my notes while implement caneweb - a gin-like minimal web framework/router after reading the first section of 7 days golang by geektutu (https://github.com/geektutu/7days-golang).\nHow standard net/http package handle request? First, let\u0026rsquo;s look at a sample written with net/http package:\nfunc main() { http.HandleFunc(\u0026#34;/\u0026#34;, handler) http.HandleFunc(\u0026#34;/post\u0026#34;, getAllPost) log.Fatal(http.ListenAndServe(\u0026#34;localhost:8000\u0026#34;, nil)) } func handler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;URL.Path = %q\\n\u0026#34;, r.URL.Path) } This piece of code binds two endpoints with the corresponding handler function, and starts a web server at port 8000, terminates the server if some errors are returned.","title":"Create a web framework in Go part 1: static routing"},{"content":"Tại sao lại có bài viết này?: Design pattern: Những giải pháp có thể tái sử dụng cho các vấn đề thường gặp tại một ngữ cảnh nhất định trong quá trinh thiết kế phần mềm.\nBài viết này nói về một số Design pattern \u0026ldquo;thân thiện\u0026rdquo; hơn trong go, được mình tổng hợp dựa trên buổi talk của Ryan Djurovich (https://www.youtube.com/watch?v=HHqv3_rUr88) và một số nguồn tài liệu khác mà mình đọc được.\nFactory pattern Khỏi phải nói về độ phổ biến của nó rồi, rất hữu ích khi cần phải khởi tạo một đối tượng có nhiều triển khai (concrete types), phía client chỉ cần quan tâm đến các method, Factory sẽ lo việc lựa chọn triển khai nào sẽ được dùng để xử lý dữ liệu.\n// use Stringer as the interface type ErrPrint struct{} func (p *ErrPrint) String() string { return \u0026#34;some error happens\u0026#34; } type InfoPrint struct{} func (p *InfoPrint) String() string { return \u0026#34;nothing dramatically happens\u0026#34; } func NewPrinter(kind string) (result fmt.Stringer, err error) { switch kind { case \u0026#34;error\u0026#34;: result = \u0026amp;ErrPrint{} case \u0026#34;info\u0026#34;: result = \u0026amp;InfoPrint{} default: err = errors.New(\u0026#34;invalid kind\u0026#34;) } return } Decorator (Functional option) Để nói về pattern này, đầu tiên hãy xem ví dụ bên dưới:\nfunc runServer() { http.HandleFunc(\u0026#34;/\u0026#34;, helloEndpoint) log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil)) } func helloEndpoint(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;Hello world\u0026#34;) } Đoạn code trên tạo ra một web server đơn giản với net/http package với một endpoint duy nhất. Bài toán được đặt ra là bây giờ cần log lại thời gian cần để hoàn tất xử lý request. Để gia tăng tính tái sử dụng, tránh phải sửa lại handler, cũng như dễ dàng bảo trì về sau, ta có thể viết như sau:\nfunc runServer() { http.HandleFunc(\u0026#34;/\u0026#34;, durationLogger(helloEndpoint)) log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil)) } func helloEndpoint(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;Hello world\u0026#34;) } func durationLogger(f http.HandlerFunc) http.HandlerFunc { return func(writer http.ResponseWriter, request *http.Request) { startTime := time.Now() f(writer, request) log.Printf(\u0026#34;complete handle request after %s ms\u0026#34;, time.Since(startTime).Milliseconds()) } } Như vậy, chúng ta có thể dễ dàng thêm tính năng log thời gian này vào những handler cần thiết, việc thay đổi nội dung log cũng trở nên dễ dàng hơn. Đây chỉ là một ví dụ đơn giản về middleware, trong thực tế việc triển khai có thể phức tạp hơn để phù hợp với các nhù cầu khác nhau.\nIterator Tại sao lại cần pattern này thay vì duyệt (array, slice, map, channel\u0026hellip;) trong go?\nCó thể kết hợp với decorator Khi viết một module nào đó mà muốn che giấu triển khai bên dưới, chỉ cho phép phía sử dụng duyệt tuần tự các phần tử. Ví dụ io.Reader, sql/database.Row type Iterator struct { tasks []string position int } // Next will return the next task in the slice // if there\u0026#39;s more data to iterate, more will be true func (t *Iterator) Next() (pos int, val string, more bool) { t.position++ if t.position \u0026gt; len(t.tasks) { return t.position, \u0026#34;\u0026#34;, false } return t.position, t.tasks[t.position-1], true } Trên đây là một ví dụ đơn giản về triển khai iterator trong go\nfor _, val, more := i.Next(); more; _, val, more = i.Next() { fmt.Println(val) } Dependency Injection DI trong go có thể được triển khai theo nhiều cách, có cả những thư viện chuyên dùng để DI trong go (google/wire, uber-go/fx), trong bài viết này sẽ chỉ nói vể cách triển khai đơn giản nhất\n┌────────────────────┬──────────┬────────────────────────────────┬────────┐ │ Client package │ Client ├─────► \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; │ │ │ └──────────┘ │ Client Service Interface │ │ │ └─────▲────────────────────┘ │ │ │ │ ├───────────────────────────────────────────┼─────────────────────────────┤ ├───────────────────────────┼───────────────|─────┼─┼──────────────────┼──┤ │ Service package │ Concrete Service 1 │ │Concrete Service 2│ │ │ └─────────────────────┘ └──────────────────┘ │ │ │ │ │ └─────────────────────────────────────────────────────────────────────────┘ Đây là một đoạn code ví dụ co dependency injection sử dụng constructor\nfunc main() { s := NewMyService(os.Stderr) s.WriteHello(\u0026#34;world\u0026#34;) } type MyService struct { writer io.Writer } func NewMyService(writer io.Writer) MyService { return MyService{ writer: writer, } } func (s *MyService) WriteHello(m string) { fmt.Fprintf(s.writer, \u0026#34;Hello %s\\n\u0026#34;, m) } Thêm method để có thể sử dụng setter injection:\nfunc (s *MyService) SetWriter(w io.Writer) { s.writer = w } So sánh hai cách:\nconstructor: Đảm bảo dependency được sử dụng luôn valid setter: Có thể thay thế concrete service trong quá trình chạy chương trình(runtime) Repository Một pattern trong thiết kế phần mếm hướng tới việc tiến hóa lâu dài của ứng dụng, các module phụ thuộc có thể được thay đổi trong tương lai. Ví dụ dưới đề thể hiện việc triển khai một ứng dụng mà lớp storage có thể được thay đổi: package post - khai báo model\ntype Post struct { ID int64 Title string } package domain - khai báo các interface client sử dụng để thao tác với storage\n// Repository must be implemented by all implementations of Post storage type Repository interface { FindAll() ([]post.Post, error) Store(post post.Post) (post.Post, error) DeleteById(postId int64) error } package memstorage - một triển khai của storage\n//in-memory implementation type PostStorage struct { posts map[int64]string highestID int64 } func (p *PostStorage) FindAll() ([]post.Post, error) { result := make([]post.Post, 0) for id, title := range p.posts { result = append(result, post.Post{ ID: id, Title: title, }) } return result, nil } func (p *PostStorage) Store(post post.Post) (post.Post, error) { if p.posts == nil { p.posts = make(map[int64]string) } if post.ID \u0026lt;= 0 { p.highestID++ post.ID = p.highestID } else { if _, exists := p.posts[post.ID]; !exists { return post, fmt.Errorf(\u0026#34;post already exist\u0026#34;) } } p.posts[post.ID] = post.Title return post, nil } func (p *PostStorage) DeleteById(postId int64) error { delete(p.posts, postId) return nil } Sử dụng repository package: package main\nfunc main() { postRepo := memstorage.PostStorage{} //may change to other implementation in the future newPost, err := postRepo.Store(post.Post{ Title: \u0026#34;Eagles fly\u0026#34;, }) if err != nil { log.Println(\u0026#34;can not create post\u0026#34;, err) } else { log.Printf(\u0026#34;created post with id %d\u0026#34;, newPost.ID) } posts, err := postRepo.FindAll() if err != nil { log.Println(\u0026#34;can not fetch posts\u0026#34;, err) } else { log.Println(posts) } } Bằng cách chia nhỏ việc triển khai, domain interface và model, trong trường hợp một phần mềm cần thay thế các module trong tương lai, có thể update một cách dễ dàng.\nMã nguồn trong bài viết có thể xem tại: https://github.com/DucHoangManh/go-patterns\n","permalink":"https://duchoangmanh.github.io/posts/technical/design-pattern-than-thien-trong-go/","summary":"Tại sao lại có bài viết này?: Design pattern: Những giải pháp có thể tái sử dụng cho các vấn đề thường gặp tại một ngữ cảnh nhất định trong quá trinh thiết kế phần mềm.\nBài viết này nói về một số Design pattern \u0026ldquo;thân thiện\u0026rdquo; hơn trong go, được mình tổng hợp dựa trên buổi talk của Ryan Djurovich (https://www.youtube.com/watch?v=HHqv3_rUr88) và một số nguồn tài liệu khác mà mình đọc được.","title":"Design pattern thân thiện trong go"}]