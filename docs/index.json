[{"content":"This post contains my notes while implement caneweb - a gin-like minimal web framework/router after reading the first section of 7 days golang by geektutu (https://github.com/geektutu/7days-golang).\nHow standard net/http package handle request? First, let\u0026rsquo;s look at a sample written with net/http package:\nfunc main() { http.HandleFunc(\u0026#34;/\u0026#34;, handler) http.HandleFunc(\u0026#34;/post\u0026#34;, getAllPost) log.Fatal(http.ListenAndServe(\u0026#34;localhost:8000\u0026#34;, nil)) } func handler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;URL.Path = %q\\n\u0026#34;, r.URL.Path) } This piece of code binds two endpoints with the corresponding handler function, and starts a web server at port 8000, terminates the server if some errors are returned.\nAll http handlers must implement the handler interface, and we can use multiple handlers to handle a single request by passing the parameters around:\ntype Handler interface { ServeHTTP(ResponseWriter, *Request) } The standard library package does provide basic functions to create a web server including monitor port, static routing, request parsing\u0026hellip; Some other functions need to be implemented when necessary:\n Dynamic routing: routing with rules like post/:id, post/*,\u0026hellip; or using regular expression. Middleware: By passing around the request, and response between multiple functions to change the result. Group requests: Group endpoints into a cluster that share some commons. Validate requests. \u0026hellip;  Create the static-routing version of the framework First, we need to design a struct that represents the state of the current request data and have methods to easily work with requests.\nWhy encapsulate response and request into a single struct?  Reduce the complexity of the handler, a user no longer need to care about which data resides in request, or responseWriter Easier to create a response and less error-prone, reduce repetitive  For example, in order to write the response for a request, instead of\nobj = map[string]interface{}{ \u0026#34;title\u0026#34;: \u0026#34;my first blog post\u0026#34;, \u0026#34;read_time\u0026#34;: \u0026#34;5\u0026#34;, } w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) w.WriteHeader(http.StatusOK) encoder := json.NewEncoder(w) if err := encoder.Encode(obj); err != nil { http.Error(w, err.Error(), 500) } We can achive the same result in a simpler and clearer way:\nc.JSON(http.StatusOK, cane.Map{ \u0026#34;title\u0026#34;: \u0026#34;my first blog post\u0026#34;, \u0026#34;read_time\u0026#34;: 5, }) ctx.go\npackage cane import \u0026#34;net/http\u0026#34; type Ctx struct { // origin objects  Writer http.ResponseWriter Req *http.Request // request data  Path string Method string // response data  StatusCode int } // newCtx create new Ctx with original data func newCtx(w http.ResponseWriter, r *http.Request) *Ctx { return \u0026amp;Ctx{ Writer: w, Req: r, Path: r.URL.Path, Method: r.Method, } } Add some functions to work with request and reponse morre efficiently:\n// responseWriter func (c *Ctx) SetHeader(key, value string) { c.Writer.Header().Set(key, value) } func (c *Ctx) Status(code int) { c.StatusCode = code c.Writer.WriteHeader(code) } func (c *Ctx) String(code int, formatString string, values ...interface{}) { c.SetHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/plain\u0026#34;) c.Status(code) _, err := fmt.Fprintf(c.Writer, formatString, values...) if err != nil { http.Error(c.Writer, err.Error(), http.StatusInternalServerError) } } func (c *Ctx) JSON(code int, data interface{}) { c.SetHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) c.Status(code) encoder := json.NewEncoder(c.Writer) err := encoder.Encode(data) if err != nil { http.Error(c.Writer, err.Error(), http.StatusInternalServerError) } } func (c *Ctx) HTML(code int, html string) { c.SetHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/html\u0026#34;) c.Status(code) _, err := c.Writer.Write([]byte(html)) if err != nil { http.Error(c.Writer, err.Error(), http.StatusInternalServerError) } } // request func (c *Ctx) FormValue(key string) string { return c.Req.FormValue(key) } func (c *Ctx) Query(key string) string { return c.Req.URL.Query().Get(key) } Our handler interface should look like this:\ntype Handler interface { Serve(c *Ctx) } Instead of creating a struct for each handler, we can use an adapter to use a function for a simple task, like in the standard net/http package:\ntype HandleFunc func(c *Ctx) func (f HandleFunc) Serve(c *Ctx) { f(c) } The static-routing router Now, we need an object to keep all our static routing configurations and decide which handler to use with each URL and method a.k.a router In this first version of the web framework, I simply use a map to represent the router with static routing:\nrouter.go\ntype router struct { handlers map[string]Handler } func newRouter() *router { return \u0026amp;router{ handlers: make(map[string]Handler), } } // create route from method and path func getRoute(method, path string) (route string) { var builder strings.Builder fmt.Fprintf(\u0026amp;builder, \u0026#34;%s%s%s\u0026#34;, method, \u0026#34;-\u0026#34;, path) route = builder.String() return } // add a new route to the router func (r *router) addRoute(method, path string, handler Handler) { log.Printf(\u0026#34;add route %s %s\u0026#34;, method, path) route := getRoute(method, path) r.handlers[route] = handler } //route request to appropriate handler, error code if no handler found func (r *router) handle(c *Ctx) { route := getRoute(c.Method, c.Path) if handler, ok := r.handlers[route]; ok { handler.Serve(c) } else { c.Writer.WriteHeader(http.StatusNotFound) c.String(http.StatusNotFound, \u0026#34;No route found\u0026#34;) } } Create the interface of caneweb Lastly, we need a layer for the user to work with the web framework, by hiding the internal implementation of the router and such.\ntype Engine struct { router *router } // constructor of cane web framework func New() *Engine { return \u0026amp;Engine{ router: newRouter(), } } func (e *Engine) addRoute(method, pattern string, handler Handler) { e.router.addRoute(method, pattern, handler) } // define some simple operations func (e *Engine) GET(pattern string, handler Handler) { e.addRoute(http.MethodGet, pattern, handler) } func (e *Engine) POST(pattern string, handler Handler) { e.addRoute(http.MethodPost, pattern, handler) } // implement the standard package Handler interface // and transform incoming request to our handler func (e *Engine) ServeHTTP(w http.ResponseWriter, r *http.Request) { ctx := newCtx(w, r) e.router.handle(ctx) } func (e *Engine) Run(addr string) error { return http.ListenAndServe(addr, e) } Create a simple server with the framework main.go\npackage main import ( \u0026#34;caneweb/cane\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { server := cane.New() server.GET(\u0026#34;/hello\u0026#34;, cane.HandleFunc(hello)) server.POST(\u0026#34;/post\u0026#34;, cane.HandleFunc(createPost)) log.Fatal(server.Run(\u0026#34;:5445\u0026#34;)) } func hello(c *cane.Ctx) { c.String(http.StatusOK, \u0026#34;hello %s\u0026#34;, c.Query(\u0026#34;name\u0026#34;)) } func createPost(c *cane.Ctx) { title := c.FormValue(\u0026#34;title\u0026#34;) desc := c.FormValue(\u0026#34;desc\u0026#34;) c.JSON(http.StatusOK, cane.Map{ \u0026#34;post_title\u0026#34;: title, \u0026#34;description\u0026#34;: desc, }) } Send requests to the web server with curl.\ncurl \u0026#34;127.0.0.1:5445/hello?name=duchm\u0026#34; hello duchm curl \u0026#34;http://localhost:5445/post\u0026#34; -X POST -d \u0026#39;title=\u0026#34;first post\u0026#34;\u0026amp;desc=\u0026#34;rainny day\u0026#34;\u0026#39; {\u0026#34;description\u0026#34;:\u0026#34;\\\u0026#34;rainny day\\\u0026#34;\u0026#34;,\u0026#34;post_title\u0026#34;:\u0026#34;\\\u0026#34;first post\\\u0026#34;\u0026#34;} curl \u0026#34;127.0.0.1:5445/any\u0026#34; No route found That\u0026rsquo;s it, after this, we have implemented the prototype version of caneweb framework in go. Currently, the framework does nothing more than the standard net/http package but worry not, some other nice features will be added in the next versions.\nSee the source code at https://github.com/DucHoangManh/caneweb\n","permalink":"https://duchoangmanh.github.io/page/posts/technical/create-a-web-framework-in-go/","summary":"This post contains my notes while implement caneweb - a gin-like minimal web framework/router after reading the first section of 7 days golang by geektutu (https://github.com/geektutu/7days-golang).\nHow standard net/http package handle request? First, let\u0026rsquo;s look at a sample written with net/http package:\nfunc main() { http.HandleFunc(\u0026#34;/\u0026#34;, handler) http.HandleFunc(\u0026#34;/post\u0026#34;, getAllPost) log.Fatal(http.ListenAndServe(\u0026#34;localhost:8000\u0026#34;, nil)) } func handler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;URL.Path = %q\\n\u0026#34;, r.URL.Path) } This piece of code binds two endpoints with the corresponding handler function, and starts a web server at port 8000, terminates the server if some errors are returned.","title":"Create a web framework in Go part 1: static routing prototype"},{"content":"Tại sao lại có bài viết này?: Design pattern: Những giải pháp có thể tái sử dụng cho các vấn đề thường gặp tại một ngữ cảnh nhất định trong quá trinh thiết kế phần mềm.\nBài viết này nói về một số Design pattern \u0026ldquo;thân thiện\u0026rdquo; hơn trong go, được mình tổng hợp dựa trên buổi talk của Ryan Djurovich (https://www.youtube.com/watch?v=HHqv3_rUr88) và một số nguồn tài liệu khác mà mình đọc được.\nFactory pattern Khỏi phải nói về độ phổ biến của nó rồi, rất hữu ích khi cần phải khởi tạo một đối tượng có nhiều triển khai (concrete types), phía client chỉ cần quan tâm đến các method, Factory sẽ lo việc lựa chọn triển khai nào sẽ được dùng để xử lý dữ liệu.\n// use Stringer as the interface  type ErrPrint struct{} func (p *ErrPrint) String() string { return \u0026#34;some error happens\u0026#34; } type InfoPrint struct{} func (p *InfoPrint) String() string { return \u0026#34;nothing dramatically happens\u0026#34; } func NewPrinter(kind string) (result fmt.Stringer, err error) { switch kind { case \u0026#34;error\u0026#34;: result = \u0026amp;ErrPrint{} case \u0026#34;info\u0026#34;: result = \u0026amp;InfoPrint{} default: err = errors.New(\u0026#34;invalid kind\u0026#34;) } return } Decorator (Functional option) Để nói về pattern này, đầu tiên hãy xem ví dụ bên dưới:\nfunc runServer() { http.HandleFunc(\u0026#34;/\u0026#34;, helloEndpoint) log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil)) } func helloEndpoint(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;Hello world\u0026#34;) } Đoạn code trên tạo ra một web server đơn giản với net/http package với một endpoint duy nhất. Bài toán được đặt ra là bây giờ cần log lại thời gian cần để hoàn tất xử lý request. Để gia tăng tính tái sử dụng, tránh phải sửa lại handler, cũng như dễ dàng bảo trì về sau, ta có thể viết như sau:\nfunc runServer() { http.HandleFunc(\u0026#34;/\u0026#34;, durationLogger(helloEndpoint)) log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil)) } func helloEndpoint(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;Hello world\u0026#34;) } func durationLogger(f http.HandlerFunc) http.HandlerFunc { return func(writer http.ResponseWriter, request *http.Request) { startTime := time.Now() f(writer, request) log.Printf(\u0026#34;complete handle request after %s ms\u0026#34;, time.Since(startTime).Milliseconds()) } } Như vậy, chúng ta có thể dễ dàng thêm tính năng log thời gian này vào những handler cần thiết, việc thay đổi nội dung log cũng trở nên dễ dàng hơn. Đây chỉ là một ví dụ đơn giản về middleware, trong thực tế việc triển khai có thể phức tạp hơn để phù hợp với các nhù cầu khác nhau.\nIterator Tại sao lại cần pattern này thay vì duyệt (array, slice, map, channel\u0026hellip;) trong go?\n Có thể kết hợp với decorator Khi viết một module nào đó mà muốn che giấu triển khai bên dưới, chỉ cho phép phía sử dụng duyệt tuần tự các phần tử. Ví dụ io.Reader, sql/database.Row  type Iterator struct { tasks []string position int } // Next will return the next task in the slice // if there\u0026#39;s more data to iterate, more will be true func (t *Iterator) Next() (pos int, val string, more bool) { t.position++ if t.position \u0026gt; len(t.tasks) { return t.position, \u0026#34;\u0026#34;, false } return t.position, t.tasks[t.position-1], true } Trên đây là một ví dụ đơn giản về triển khai iterator trong go\nfor _, val, more := i.Next(); more; _, val, more = i.Next() { fmt.Println(val) } Dependency Injection DI trong go có thể được triển khai theo nhiều cách, có cả những thư viện chuyên dùng để DI trong go (google/wire, uber-go/fx), trong bài viết này sẽ chỉ nói vể cách triển khai đơn giản nhất\n┌────────────────────┬──────────┬────────────────────────────────┬────────┐ │ Client package │ Client ├─────► \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; │ │ │ └──────────┘ │ Client Service Interface │ │ │ └─────▲────────────────────┘ │ │ │ │ ├───────────────────────────────────────────┼─────────────────────────────┤ ├───────────────────────────┼───────────────|─────┼─┼──────────────────┼──┤ │ Service package │ Concrete Service 1 │ │Concrete Service 2│ │ │ └─────────────────────┘ └──────────────────┘ │ │ │ │ │ └─────────────────────────────────────────────────────────────────────────┘ Đây là một đoạn code ví dụ co dependency injection sử dụng constructor\nfunc main() { s := NewMyService(os.Stderr) s.WriteHello(\u0026#34;world\u0026#34;) } type MyService struct { writer io.Writer } func NewMyService(writer io.Writer) MyService { return MyService{ writer: writer, } } func (s *MyService) WriteHello(m string) { fmt.Fprintf(s.writer, \u0026#34;Hello %s\\n\u0026#34;, m) } Thêm method để có thể sử dụng setter injection:\nfunc (s *MyService) SetWriter(w io.Writer) { s.writer = w } So sánh hai cách:\n constructor: Đảm bảo dependency được sử dụng luôn valid setter: Có thể thay thế concrete service trong quá trình chạy chương trình(runtime)  Repository Một pattern trong thiết kế phần mếm hướng tới việc tiến hóa lâu dài của ứng dụng, các module phụ thuộc có thể được thay đổi trong tương lai. Ví dụ dưới đề thể hiện việc triển khai một ứng dụng mà lớp storage có thể được thay đổi: package post - khai báo model\ntype Post struct { ID int64 Title string } package domain - khai báo các interface client sử dụng để thao tác với storage\n// Repository must be implemented by all implementations of Post storage type Repository interface { FindAll() ([]post.Post, error) Store(post post.Post) (post.Post, error) DeleteById(postId int64) error } package memstorage - một triển khai của storage\n//in-memory implementation type PostStorage struct { posts map[int64]string highestID int64 } func (p *PostStorage) FindAll() ([]post.Post, error) { result := make([]post.Post, 0) for id, title := range p.posts { result = append(result, post.Post{ ID: id, Title: title, }) } return result, nil } func (p *PostStorage) Store(post post.Post) (post.Post, error) { if p.posts == nil { p.posts = make(map[int64]string) } if post.ID \u0026lt;= 0 { p.highestID++ post.ID = p.highestID } else { if _, exists := p.posts[post.ID]; !exists { return post, fmt.Errorf(\u0026#34;post already exist\u0026#34;) } } p.posts[post.ID] = post.Title return post, nil } func (p *PostStorage) DeleteById(postId int64) error { delete(p.posts, postId) return nil } Sử dụng repository package: package main\nfunc main() { postRepo := memstorage.PostStorage{} //may change to other implementation in the future \tnewPost, err := postRepo.Store(post.Post{ Title: \u0026#34;Eagles fly\u0026#34;, }) if err != nil { log.Println(\u0026#34;can not create post\u0026#34;, err) } else { log.Printf(\u0026#34;created post with id %d\u0026#34;, newPost.ID) } posts, err := postRepo.FindAll() if err != nil { log.Println(\u0026#34;can not fetch posts\u0026#34;, err) } else { log.Println(posts) } } Bằng cách chia nhỏ việc triển khai, domain interface và model, trong trường hợp một phần mềm cần thay thế các module trong tương lai, có thể update một cách dễ dàng.\nMã nguồn trong bài viết có thể xem tại: https://github.com/DucHoangManh/go-patterns\n","permalink":"https://duchoangmanh.github.io/page/posts/technical/design-pattern-than-thien-trong-go/","summary":"Tại sao lại có bài viết này?: Design pattern: Những giải pháp có thể tái sử dụng cho các vấn đề thường gặp tại một ngữ cảnh nhất định trong quá trinh thiết kế phần mềm.\nBài viết này nói về một số Design pattern \u0026ldquo;thân thiện\u0026rdquo; hơn trong go, được mình tổng hợp dựa trên buổi talk của Ryan Djurovich (https://www.youtube.com/watch?v=HHqv3_rUr88) và một số nguồn tài liệu khác mà mình đọc được.","title":"Design pattern thân thiện trong go"}]