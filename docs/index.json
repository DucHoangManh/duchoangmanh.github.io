[{"content":"Reflection trong Go Reflection trong go giÃºp cho ta cÃ³ thá»ƒ theo dÃµi code táº¡i thá»i Ä‘iá»ƒm runtime, cho phÃ©p tiáº¿p cáº­n mÃ£ nguá»“n chÆ°Æ¡ng trÃ¬nh dÆ°á»›i dáº¡ng data cÃ³ thá»ƒ xá»­ lÃ½ thay vÃ¬ cÃ¡c lá»‡nh cÃ³ thá»ƒ thá»±c thi (má»™t nhÃ¡nh trong metaprogramming).\nReflection trong go cÃ³ thá»ƒ Ä‘Æ°á»£c thá»±c hiá»‡n thÃ´ng qua reflect package. Má»™t sá»‘ kháº£ nÄƒng cá»§a reflect:\n Kiá»ƒm tra thÃ´ng tin cá»§a má»™t struct (sá»‘ lÆ°á»£ng method, sá»‘ lÆ°á»£ng field, Ä‘á»c struct tag\u0026hellip;) mÃ  khÃ´ng cáº§n biáº¿t trÆ°á»›c vá» struct Ä‘Ã³. Kiá»ƒm tra vÃ  cáº­p nháº­t má»™t type (slice, channel, struct, interface, pointer\u0026hellip;) mÃ  khÃ´ng cáº§n biáº¿t trÆ°á»›c vá» type Ä‘Ã³.  Äá»•i láº¡i nhá»¯ng kháº£ nÄƒng máº¡nh máº½ cá»§a recflect, performance vÃ  tÃ­nh maintainable cá»§a code sáº½ giáº£m, cáº§n cÃ¢n nháº¯c kÄ© trÆ°á»›c khi quyáº¿t Ä‘á»‹nh Ä‘Æ°a vÃ o á»©ng dá»¥ng.\n Clear is better than clever. Reflection is never clear - Go proverb (Rob Pike)\n á»¨ng dá»¥ng cá»§a reflect:\n CÃ¡c function, method vá»›i Ä‘áº§u vÃ o khÃ´ng rÃµ trÆ°á»›c. Viáº¿t cÃ´ng cá»¥ phÃ¢n tÃ­ch mÃ£ nguá»“n. Thá»±c thi code linh hoáº¡t (VD liá»‡t kÃª cÃ¡c method cá»§a má»™t struct vÃ  gá»i method theo tÃªn).  Má»™t sá»‘ package, library sá»­ dá»¥ng reflection: fmt, encoding/json, gorm, sqlx\u0026hellip;\nCÃ¡c khÃ¡i niá»‡m quan trá»ng CÃ³ hai type quan trá»ng trong reflect package: reflect.Type vÃ  reflect.Value, má»i biáº¿n trong má»™t chÆ°Æ¡ng trÃ¬nh cÃ³ thá»ƒ Ä‘Æ°á»£c thá»ƒ hiá»‡n bá»Ÿi má»™t cáº·p Value vÃ  Type. reflect.Type vÃ  reflect.Value nhÆ° tÃªn gá»i chá»©a cÃ¡c thÃ´ng tin tÆ°Æ¡ng á»©ng vá» type vÃ  value cá»§a biáº¿n Ä‘ang xem xÃ©t, Ä‘i kÃ¨m cÃ¡c utilitiy funtion vÃ  method Ä‘á»ƒ thao tÃ¡c vá»›i data. CÃ¡c giÃ¡ trá»‹ nÃ y cá»§a má»™t biáº¿n x báº¥t kÃ¬ cÃ³ thá»ƒ Ä‘Æ°á»£c láº¥y báº±ng reflect.ValueOf(x) vÃ  reflect.TypeOf(x):\ntype Person struct { Name string Age int } p := Person{ Name: \u0026#34;Duc\u0026#34;, Age: 10, } pp := \u0026amp;p o := []int{1, 2, 3} s := \u0026#34;reflect in go\u0026#34; fmt.Printf(\u0026#34;(%v, %v)\\n\u0026#34;, reflect.ValueOf(p), reflect.TypeOf(p)) fmt.Printf(\u0026#34;(%v, %v)\\n\u0026#34;, reflect.ValueOf(pp), reflect.TypeOf(pp)) fmt.Printf(\u0026#34;(%v, %v)\\n\u0026#34;, reflect.ValueOf(o), reflect.TypeOf(o)) fmt.Printf(\u0026#34;(%v, %v)\\n\u0026#34;, reflect.ValueOf(s), reflect.TypeOf(s)) Káº¿t quáº£:\n({Duc 10}, main.Person) (\u0026amp;{Duc 10}, *main.Person) ([1 2 3], []int) (reflect in go, string) NgoÃ i ra ta cÅ©ng cÃ³ thá»ƒ Ä‘á»c Ä‘Æ°á»£c thÃªm má»™t sá»‘ thÃ´ng tin quan trá»ng khÃ¡c nhÆ° reflect.Kind - chá»©a thÃ´ng tin cá»¥ thá»ƒ hÆ¡n vá» kiá»ƒu cá»§a má»™t biáº¿n, cÃ³ thá»ƒ truy cáº­p báº±ng Value.Kind() hoáº·c Type.Kind():\nfmt.Printf(\u0026#34;(%v, %v)\\n\u0026#34;, reflect.TypeOf(p), reflect.ValueOf(p).Kind()) fmt.Printf(\u0026#34;(%v, %v)\\n\u0026#34;, reflect.TypeOf(pp), reflect.ValueOf(pp).Kind()) fmt.Printf(\u0026#34;(%v, %v)\\n\u0026#34;, reflect.TypeOf(o), reflect.ValueOf(o).Kind()) fmt.Printf(\u0026#34;(%v, %v)\\n\u0026#34;, reflect.TypeOf(s), reflect.ValueOf(s).Kind()) Káº¿t quáº£:\n(main.Person, struct) (*main.Person, ptr) ([]int, slice) (string, string) Parse url query vá»›i reflection XÃ©t bÃ i toÃ¡n cáº§n viáº¿t má»™t hÃ m nháº­n vÃ o má»™t *http.Request vÃ  má»™t struct sau Ä‘Ã³ fill dá»¯ liá»‡u tá»« URL query vÃ o struct Ä‘Ã³:\ntype Person struct { Name string Age int } func ParseQuery(r *http.Request, p *Person) (err error) { q := r.URL.Query() p.Name = q.Get(\u0026#34;name\u0026#34;) p.Age, err = strconv.Atoi(q.Get(\u0026#34;age\u0026#34;)) return err } func TestParseQuery(t *testing.T) { req, _ := http.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;/root?name=Duc\u0026amp;age=10\u0026#34;, nil) var d Person err := Parse(req, \u0026amp;d) if err != nil { t.Error(err.Error()) } fmt.Println(d) // {Duc 10} } Má»™t vÃ­ dá»¥ khÃ¡ cÆ¡ báº£n vÃ  thÆ°á»ng gáº·p pháº£i khÃ´ng? Tuy nhiÃªn cÃ¡ch lÃ m nÃ y sáº½ cáº§n pháº£i láº·p láº¡i code khÃ¡ nhiá»u.\nVáº­y thay vÃ¬ biáº¿t trÆ°á»›c struct Ä‘Æ°á»£c truyá»n vÃ o lÃ  Person thÃ¬ ta cÃ³ thá»ƒ truyá»n má»™t struct báº¥t kÃ¬ vá»›i cÃ¡c field cÃ³ tÃªn á»©ng vá»›i cÃ¡c query cÃ³ thá»ƒ gáº·p mÃ  váº«n Ä‘áº¡t Ä‘Æ°á»£c káº¿t quáº£ tÆ°Æ¡ng tá»± hay khÃ´ng? Vá»›i reflect thÃ¬ hoÃ n toÃ n cÃ³ thá»ƒ.\nÃ tÆ°á»Ÿng lÃ  cÃ³ thá»ƒ dÃ¹ng reflect Ä‘á»ƒ Ä‘á»c thÃ´ng tin cá»§a struct báº¥t ká»³ Ä‘Æ°á»£c truyá»n vÃ o, duyá»‡t qua láº§n lÆ°á»£t cÃ¡c field, vÃ  kiá»ƒm tra xem trong URL cÃ³ query nÃ o tÆ°Æ¡ng á»©ng vá»›i field Ä‘ang xÃ©t hay khÃ´ng, náº¿u cÃ³ thÃ¬ Ä‘á»c giÃ¡ trá»‹ cá»§a query vÃ o field.\nBáº¯t tay vÃ o code Tá»•ng quan cá»§a chÆ°Æ¡ng trÃ¬nh cÃ³ thá»ƒ Ä‘Æ°á»£c thá»ƒ hiá»‡n nhÆ° sau:\nfunc Parse(r *http.Request, dest any) (err error) { v := reflect.ValueOf(dest) q := r.URL.Query() if v.Kind() != reflect.Ptr || v.Elem().Kind() != reflect.Struct { return fmt.Errorf(\u0026#34;dest must be a pointer to a struct\u0026#34;) } v = v.Elem() t := v.Type() for i := 0; i \u0026lt; v.NumField(); i++ { fVal := v.Field(i) fType := t.Field(i) fName := strings.ToLower(fType.Name) err = parse(q.Get(fName), fVal) if err != nil { return fmt.Errorf(\u0026#34;parse %w\u0026#34;, err) } } return nil } func parse(stringVal string, destVal reflect.Value) (err error) { // xá»­ lÃ½ cá»¥ thá»ƒ cho tá»«ng field } LÆ°u Ã½ lÃ  báº¯t buá»™c Ä‘áº§u vÃ o cá»§a hÃ m pháº£i lÃ  má»™t con trá» tá»›i struct thÃ¬ reflect má»›i cÃ³ thá»ƒ thay Ä‘á»•i Ä‘Æ°á»£c struct Ä‘Ã³, ta cÃ³ thá»ƒ kiá»ƒm tra Ä‘iá»u kiá»‡n nÃ y vá»›i v.Kind() == reflect.Ptr vÃ  v.Elem().Kind() == reflect.Struct - VÃ¬ ta expect giÃ¡ trá»‹ truyá»n vÃ o lÃ  con trá» (tÆ°Æ¡ng á»©ng reflect.Ptr nÃªn cáº§n gá»i Elem() Ä‘á»ƒ láº¥y ra giÃ¡ trá»‹ thá»±c á»Ÿ sau con trá» Ä‘Ã³) Sau khi Ä‘Ã£ cÃ³ Ä‘Æ°á»£c Type vÃ  Value cá»§a struct Ä‘áº§u vÃ o rá»“i, ta sáº½ tiáº¿n hÃ nh duyá»‡t qua tá»«ng field vÃ  xá»­ lÃ½ cá»¥ thá»ƒ á»Ÿ trong hÃ m parse\nfunc parse(stringVal string, destVal reflect.Value) (err error) { if stringVal == \u0026#34;\u0026#34; { // bá» qua náº¿u nhÆ° khÃ´ng cÃ³ query tÆ°Æ¡ng á»©ng vá»›i field nÃ y \treturn nil } if !destVal.CanSet() { return fmt.Errorf(\u0026#34;field unexported or cannot set value\u0026#34;) } k := destVal.Kind() switch { case k == reflect.String: err = parseString(stringVal, destVal) case k \u0026gt;= reflect.Int \u0026amp;\u0026amp; k \u0026lt;= reflect.Int64: err = parseInt(stringVal, destVal) default: err = fmt.Errorf(\u0026#34;type not supported: %v\u0026#34;, destVal.Type()) return err } Giáº£i thÃ­ch: Trong hÃ m nÃ y ta sáº½ kiá»ƒm tra Kind cá»§a tá»«ng field vÃ  vá»›i má»—i kind Ä‘Ã³ sáº½ cÃ³ hÃ m cá»¥ thá»ƒ Ä‘á»ƒ xá»­ lÃ½ giÃºp cho code clear hÆ¡n. Trick nhá» lÃ  thay vÃ¬ kiá»ƒm tra vá»›i tá»«ng kiá»ƒu int, int8\u0026hellip; thÃ¬ cÃ³ thá»ƒ viáº¿t k \u0026gt;= reflect.Int \u0026amp;\u0026amp; k \u0026lt;= reflect.Int64 do trong mÃ£ nguá»“n cá»§a reflect, cÃ¡c Kind cÃ³ thá»ƒ cÃ³ cá»§a biáº¿n Ä‘Æ°á»£c viáº¿t dÆ°á»›i dáº¡ng:\nconst ( Invalid Kind = iota Bool Int Int8 Int16 Int32 Int64 ... ) TÆ°Æ¡ng tá»± vá»›i uint vÃ  float.\n LÆ°u Ã½ quan trá»ng: reflect khÃ´ng thá»ƒ cáº­p nháº­t unexported field, nÃªn cáº§n kiá»ƒm tra trÆ°á»›c vá»›i CanSet() (tÆ°Æ¡ng á»©ng vá»›i CanAddr() == true vÃ  field exported). hoáº·c cÃ³ thá»ƒ kiá»ƒm tra vá»›i CanInterface()\n Viáº¿t hÃ m parse Ä‘á»‘i vá»›i tá»«ng Kind:\nfunc parseString(in string, dest reflect.Value) error { dest.SetString(in) return nil } func parseInt(in string, dest reflect.Value) error { intVal, err := strconv.ParseInt(in, 10, 0) if err != nil { return fmt.Errorf(\u0026#34;parseInt %w\u0026#34;, err) } dest.SetInt(intVal) return nil } Tiáº¿n hÃ nh cháº¡y thá»­ chÆ°Æ¡ng trÃ¬nh:\ntype Person struct { Name string Age int } func TestQueryParser(t *testing.T) { req, _ := http.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;/root?name=Duc\u0026amp;age=10\u0026#34;, nil) var d Person err := Parse(req, \u0026amp;d) if err != nil { t.Error(err.Error()) } fmt.Println(d) // {Duc 10} } It works!\nTháº¿ cÃ²n slice thÃ¬ sao? Äáº§u vÃ o:\ntype Person struct { ... IDs []int } Expect vá»›i URL query cÃ³ dáº¡ng ?ids=1,2,3, sau khi parse thÃ¬ field IDs sáº½ cÃ³ giÃ¡ trá»‹ []int{1,2,3}.\nThÃªm case Ä‘á»‘i vá»›i Kind == reflect.Slice á»Ÿ hÃ m parse\nfunc parse(stringVal string, destVal reflect.Value) (err error) { ... case k == reflect.Slice: err = parseSlice(stringVal, destVal) ... } func parseSlice(in string, dest reflect.Value) error { parts := strings.Split(in, \u0026#34;,\u0026#34;) sliceType := dest.Type().Elem() // láº¥y type cá»§a pháº§n tá»­ strong slice \tsliceLen := len(parts) sliceVal := reflect.MakeSlice(reflect.SliceOf(sliceType), sliceLen, sliceLen) // make slice tÆ°Æ¡ng á»©ng \tfor i := 0; i \u0026lt; sliceLen; i++ { // xá»­ lÃ½ cho tá»«ng pháº§n tá»­ trong slice tÆ°Æ¡ng tá»± nhÆ° struct á»Ÿ trÃªn \terr := parse(parts[i], sliceVal.Index(i)) // parse tá»«ng pháº§n tá»­ trong slice nhÆ° Ä‘Ã£ lÃ m vá»›i int vÃ  string \tif err != nil { return fmt.Errorf(\u0026#34;parseSlice %w\u0026#34;, err) } } dest.Set(sliceVal) return nil } Äá»ƒ chuyá»ƒn tá»« URL query sang slice, ta cáº§n kiá»ƒm tra xem á»Ÿ struct Ä‘Ã­ch slice cÃ³ kiá»ƒu dá»¯ liá»‡u gÃ¬ vÃ  make slice tÆ°Æ¡ng á»©ng, nhá»¯ng cÃ´ng viá»‡c sau Ä‘Ã³ khÃ´ng khÃ¡c gÃ¬ so vá»›i xá»­ lÃ½ struct á»Ÿ pháº§n trÃªn.\nCháº¡y thá»­ vá»›i slice:\ntype Person struct { Name string Age int IDs []int } func TestQueryParser(t *testing.T) { req, _ := http.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;/root?ids=1,2,3\u0026#34;, nil) var d Person err := Parse(req, \u0026amp;d) if err != nil { t.Error(err.Error()) } fmt.Println(d.IDs) // [1 2 3] } Parse query linh Ä‘á»™ng vá»›i struct tag á» phiÃªn báº£n hiá»‡n táº¡i, chÆ°Æ¡ng trÃ¬nh dá»±a trÃªn tÃªn cá»§a cÃ¡c field trong struct Ä‘á»ƒ tá»« Ä‘Ã³ láº¥y ra query tÆ°Æ¡ng á»©ng. Äá»ƒ chÆ°Æ¡ng trÃ¬nh Ä‘Æ°á»£c flexible hÆ¡n, cÃ³ thá»ƒ dÃ¹ng struct tag Ä‘á»ƒ chá»‰ Ä‘á»‹nh query tÆ°Æ¡ng á»©ng vá»›i tá»«ng field. VÃ­ dá»¥\ntype Person struct { Name string `query:\u0026#34;title\u0026#34;` ... } Vá»›i sá»± hiá»‡n diá»‡n cá»§a tag query, field Name sáº½ Ä‘Æ°á»£c parse tá»« query title, cÃ¡c field khÃ´ng cÃ³ tag query thÃ¬ behavior váº«n khÃ´ng thay Ä‘á»•i.\nBá»• sung thÃªm pháº§n Ä‘á»c struct tag cho hÃ m Parse:\nfunc Parse(r *http.Request, dest any) (err error) { v := reflect.ValueOf(dest) q := r.URL.Query() if !v.IsValid() || v.Kind() != reflect.Ptr || v.Elem().Kind() != reflect.Struct { return fmt.Errorf(\u0026#34;dest must be a pointer to not nil struct\u0026#34;) } v = v.Elem() t := v.Type() for i := 0; i \u0026lt; v.NumField(); i++ { fVal := v.Field(i) fType := t.Field(i) fName := strings.ToLower(fType.Name) if queryTag := fType.Tag.Get(\u0026#34;query\u0026#34;); queryTag != \u0026#34;\u0026#34; { // kiá»ƒm tra field cÃ³ tag query hay khÃ´ng \tfName = queryTag } err = parse(q.Get(fName), fVal) if err != nil { return fmt.Errorf(\u0026#34;parse %w\u0026#34;, err) } } return nil } VÃ  cháº¡y thá»­:\ntype Person struct { Name string `query:\u0026#34;title\u0026#34;` Age int IDs []int } func TestQueryParser(t *testing.T) { req, _ := http.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;/root?name=Duc\u0026amp;age=10\u0026amp;title=Gopher\u0026#34;, nil) var d Person err := Parse(req, \u0026amp;d) if err != nil { t.Error(err.Error()) } fmt.Println(d) // {Gopher 10 []} } Custom parse vá»›i interface Äáº¿n phiÃªn báº£n hiá»‡n táº¡i, parser Ä‘Ã£ cÃ³ thá»ƒ Ä‘áº¡p á»©ng Ä‘Æ°á»£c cÃ¡c kiá»u dá»¯ liá»‡u cÆ¡ báº£n trong Ä‘a sá»‘ trÆ°á»ng há»£p, nhÆ°ng chÆ°a thá»ƒ hoáº¡t Ä‘á»™ng Ä‘Æ°á»£c vá»›i cÃ¡c kiá»ƒu dá»¯ liá»‡u tá»± Ä‘á»‹nh nghÄ©a. VÃ­ dá»¥ vá»›i field Name, thay vÃ¬ Ä‘Æ¡n thuáº§n lÃ  má»™t string, cÃ³ thá»ƒ lÃ  struct dáº¡ng:\ntype Name struct { First string Last string } type Person struct { Name Name Age int IDs []int } Expect vá»›i URL query cÃ³ dáº¡ng ?name=duc_hoang thÃ¬ sau khi parse query, giÃ¡ trá»‹ cá»§a Person.Name sáº½ lÃ  Name{First:\u0026quot;duc\u0026quot;,Last:\u0026quot;hoang\u0026quot;}.\nMá»™t lÆ°u Ã½ khi viáº¿t cÃ¡c hÃ m hay thÆ° viá»‡n vá»›i reflect, thÃ¬ nÃªn háº¡n cháº¿ viá»‡c expose cho client pháº£i thao tÃ¡c vá»›i reflect Ä‘á»ƒ Ä‘Æ¡n giáº£n hÃ³a viá»‡c sá»­ dá»¥ng hÃ m hay thÆ° viá»‡n Ä‘Ã³. Trong trÆ°á»ng há»£p nÃ y, cÃ³ thá»ƒ dÃ¹ng má»™t interface Ä‘á»ƒ biá»ƒu thá»‹ kiá»ƒu dá»¯ liá»‡u tá»± Ä‘á»‹nh nghÄ©a cÃ³ thá»ƒ parse Ä‘Æ°á»£c, khi Parse vÃ  field Ä‘Ã­ch implement interface nÃ y thÃ¬ cÃ³ thá»ƒ dÃ¹ng hÃ m tÆ°Æ¡ng á»©ng Ä‘á»ƒ xá»­ lÃ½ field.\ntype QueryParser interface { QueryParse(string) error } Implement QueryParser interface cho kiá»ƒu Name:\nfunc (n *Name) QueryParse(in string) error { parts := strings.Split(in, \u0026#34;_\u0026#34;) if len(parts) != 2 { return fmt.Errorf(\u0026#34;invalid input\u0026#34;) } n.First = parts[0] n.Last = parts[1] return nil } LÆ°u Ã½ lÃ  cáº§n implement Ä‘á»‘i vá»›i pointer receiver Ä‘á»ƒ method cÃ³ thá»ƒ thay Ä‘á»•i giÃ¡ trá»‹ cá»§a receiver.\nTiáº¿n hÃ nh handle trong function parse:\nfunc parse(stringVal string, destVal reflect.Value) (err error) { ... default: err = parseDefault(stringVal, destVal) // chuyá»ƒn Kind máº·c Ä‘á»‹nh ra handle riÃªng Ä‘á»ƒ Ä‘áº£m báº£o code Ä‘Æ°á»£c clear vÃ  dá»… maintain \t} return err } func parseDefault(in string, dest reflect.Value) error { if dest.Kind() != reflect.Ptr { dest = dest.Addr() // láº¥y con trá» cá»§a dest náº¿u dest Ä‘ang khÃ´ng pháº£i con trá» \t} else if dest.IsNil() { dest.Set(reflect.New(dest.Type().Elem())) // khá»Ÿi taá» náº¿u dest lÃ  con trá» nil \t} if queryParser, ok := dest.Interface().(QueryParser); ok { return queryParser.QueryParse(in) // parser giÃ¡ trá»‹ tá»« query vÃ o dest \t} return fmt.Errorf(\u0026#34;type not supported: %s\u0026#34;, dest.Type().Kind()) } Trong hÃ m parseDefault, giÃ¡ trá»‹ Ä‘Ã­ch sáº½ luÃ´n Ä‘Æ°á»£c chuyá»ƒn sang kiá»ƒu con trá» trÆ°á»›c khi xÃ¡c Ä‘á»‹nh xem nÃ³ cÃ³ implement QueryParser hay khÃ´ng.\nTrong trÆ°á»ng há»£p giÃ¡ trá»‹ Ä‘Ã­ch Ä‘Ã£ lÃ  con trá» rá»“i, cáº§n kiá»ƒm tra xem cÃ³ pháº£i nil hay khÃ´ng, náº¿u lÃ  nil thÃ¬ cáº§n pháº£i khá»Ÿi táº¡o trÆ°á»›c khi gá»i method.\nVÃ  cháº¡y thá»­:\ntype Name struct { First string Last string } func (n *Name) QueryParse(in string) error { parts := strings.Split(in, \u0026#34;_\u0026#34;) if len(parts) != 2 { return fmt.Errorf(\u0026#34;invalid input\u0026#34;) } n.First = parts[0] n.Last = parts[1] return nil } type Person struct { Name Name Age int IDs []int } func TestQueryParser(t *testing.T) { req, _ := http.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;/root?name=duc_hoang\u0026#34;, nil) var d Person err := Parse(req, \u0026amp;d) if err != nil { t.Error(err.Error()) } fmt.Printf(\u0026#34;(%s, %s)\u0026#34;, d.Name.First, d.Name.Last) // (duc, hoang) } Source code trong bÃ i: https://github.com/DucHoangManh/queryparser\n","permalink":"https://duchoangmanh.github.io/posts/technical/go-reflection-qua-vi-du/","summary":"Reflection trong Go Reflection trong go giÃºp cho ta cÃ³ thá»ƒ theo dÃµi code táº¡i thá»i Ä‘iá»ƒm runtime, cho phÃ©p tiáº¿p cáº­n mÃ£ nguá»“n chÆ°Æ¡ng trÃ¬nh dÆ°á»›i dáº¡ng data cÃ³ thá»ƒ xá»­ lÃ½ thay vÃ¬ cÃ¡c lá»‡nh cÃ³ thá»ƒ thá»±c thi (má»™t nhÃ¡nh trong metaprogramming).\nReflection trong go cÃ³ thá»ƒ Ä‘Æ°á»£c thá»±c hiá»‡n thÃ´ng qua reflect package. Má»™t sá»‘ kháº£ nÄƒng cá»§a reflect:\n Kiá»ƒm tra thÃ´ng tin cá»§a má»™t struct (sá»‘ lÆ°á»£ng method, sá»‘ lÆ°á»£ng field, Ä‘á»c struct tag\u0026hellip;) mÃ  khÃ´ng cáº§n biáº¿t trÆ°á»›c vá» struct Ä‘Ã³.","title":"Go: Giá»›i thiá»‡u vá» reflection qua vÃ­ dá»¥"},{"content":"1. Kiá»ƒm tra sá»± xuáº¥t hiá»‡n cá»§a má»™t pháº§n tá»­ trong slice Type parameter hay generic lÃ  má»™t tÃ­nh nÄƒng má»›i xuáº¥t hiá»‡n tá»« phiÃªn báº£n 1.18 cá»§a Go. Vá»›i generic, ta cÃ³ thá»ƒ viáº¿t cÃ¡c hÃ m hoáº·c type cÃ³ thá»ƒ dÃ¹ng Ä‘Æ°á»£c cho nhiá»u kiá»ƒu dá»¯ liá»‡u Ä‘áº§u vÃ o khÃ¡c nhau mÃ  khÃ´ng cáº§n pháº£i láº·p láº¡i code nhiá»u láº§n.\nHÃ£y báº¯t Ä‘áº§u vá»›i má»™t vÃ­ dá»¥ Ä‘Æ¡n giáº£n vÃ  phá»• biáº¿n: Kiá»ƒm tra xem string cÃ³ xuáº¥t hiá»‡n trong slice hay khÃ´ng\nfunc StringSliceContains(ss []string, match string) bool { for _, s := range ss { if s == match { return true } } return false } RÃµ rÃ ng lÃ  trong quÃ¡ trÃ¬nh sá»­ dá»¥ng thá»±c táº¿, ta sáº½ gáº·p cÃ¡c usecase tÆ°Æ¡ng tá»± vá»›i cÃ¡c kiá»ƒu dá»¯ liá»‡u khÃ¡c. TrÆ°á»›c khi cÃ³ generic, viá»‡c phá»• biáº¿n nháº¥t sáº½ lÃ  viáº¿t riÃªng cÃ¡c hÃ m cá»¥ thá»ƒ cho tá»«ng kiá»ƒu dá»¯ liá»‡u IntSliceContains(), Int64SliceContains()\u0026hellip; bÃªn cáº¡nh viá»‡c sá»­ dá»¥ng code generation hay reflection.\nCÃ³ thá»ƒ tháº¥y cÃ¡c hÃ m nÃ y Ä‘á»u láº·p láº¡i má»™t logic giá»‘ng nhau, chá»‰ khÃ¡c á»Ÿ kiá»ƒu dá»¯ liá»‡u Ä‘áº§u vÃ o, vá»›i generic, ta hoÃ n toÃ n cÃ³ thá»ƒ rÃºt gá»n láº¡i cÃ¡c hÃ m nÃ y láº¡i thÃ nh má»™t, ráº¥t gá»n vÃ  dá»… dÃ ng báº£o trÃ¬ vá» sau:\nfunc SliceContains[T comparable](ss []T, match T) bool { for _, s := range ss { if s == match { return true } } return false } Giáº£i thÃ­ch:\n[T comparable] Ä‘Æ°á»£c gá»i lÃ  type parameter vÃ  cÃ³ thá»ƒ sá»­ dá»¥ng Ä‘Æ°á»£c vá»›i má»™t func hoáº·c má»™t type, trong trÆ°á»ng há»£p nÃ y Ã¡m chá»‰ viá»‡c hÃ m SliceContains cÃ³ thá»ƒ nháº­n vÃ o Ä‘áº§u vÃ o kiá»ƒu T thá»a mÃ£n rÃ ng buá»™c comparable.\nRÃ ng buá»™c á»Ÿ Ä‘Ã¢y lÃ  má»™t interface mÃ  T cáº§n thá»a mÃ£n, interface nÃ y cÃ³ thá»ƒ chá»©a method signature thÆ°á»ng tháº¥y hoáº·c táº­p há»£p cÃ¡c type báº¥t kÃ¬, xem thÃªm package constraints.\nTa hoÃ n toÃ n cÃ³ thá»ƒ Ä‘á»‹nh nghÄ©a constraints cÃ¹a riÃªng mÃ¬nh.\ntype MyConstraint interface { ~int | ~string } func SliceContains[T MyConstraint](ss []T, match T) bool { for _, s := range ss { if s == match { return true } } return false } NhÆ° vÃ­ dá»¥ trÃªn Ä‘Ã¢y, T cáº§n lÃ  int hoáº·c string, toÃ¡n tá»­ ~ tá»©c rÃ ng buá»™c thá»a máº£n vá»›i cáº£ cÃ¡c kiá»ƒu Ä‘Æ°á»£c Ä‘á»‹nh nghÄ©a tá»« int hoáº·c string (vÃ­ dá»¥ type Name string, type Age int)\nfunc TestSliceContains(t *testing.T) { intSlice := []int{4, 5, 6} stringSlice := []string{\u0026#34;a\u0026#34;, \u0026#34;abb\u0026#34;, \u0026#34;c\u0026#34;} fmt.Println(SliceContains(intSlice, 5)) // true \tfmt.Println(SliceContains(stringSlice, \u0026#34;c\u0026#34;)) // true } CÃ³ thá»ƒ tháº¥y lÃ  khi gá»i hÃ m khÃ´ng cáº§n chá»‰ rÃµ ra T lÃ  kiá»ƒu gÃ¬ mÃ  chá»‰ cáº§n truyá»n cÃ¡c parameter vÃ o, go cÃ³ thá»ƒ tá»± hiá»ƒu vÃ  thá»±c thi Ä‘Ãºng hÃ m mÃ  ta mong muá»‘n, SliceContains[int](intSlice, 5) cÅ©ng tÆ°Æ¡ng Ä‘Æ°Æ¡ng vá»›i SliceContains(intSlice, 5).\nTa cÅ©ng cÃ³ thá»ƒ viáº¿t má»™t hÃ m kiá»ƒm tra pháº§n tá»­ cÃ³ thuá»™c slice hay khÃ´ng mÃ  khÃ´ng cÃ³ rÃ ng buá»™c, thay vÃ o Ä‘Ã³, truyá»n vÃ o má»™t funcion equalFunc Ä‘á»ƒ sá»­ dá»¥ng thay cho toÃ¡n tá»­ ==:\nfunc SliceContainsWithEqual[T any](ss []T, match T, equalFunc func(T, T) bool) bool { for _, s := range ss { if equalFunc(s, match) { return true } } return false } 2. Generic wrapper cho container/heap Trong go, khi cáº§n sá»­ dá»¥ng heap, ta cÃ³ thá»ƒ sá»­ dá»¥ng package container/heap vÃ  implement heap.Interface cho kiá»ƒu dá»¯ liá»‡u muá»‘n sá»­ dá»¥ng.\nVÃ­ dá»¥ má»™t min heap cho kiá»ƒu int tá»« trong document cá»§a container/heap:\ntype IntHeap []int func (h IntHeap) Len() int { return len(h) } func (h IntHeap) Less(i, j int) bool { return h[i] \u0026lt; h[j] } func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *IntHeap) Push(x any) { // Push and Pop use pointer receivers because they modify the slice\u0026#39;s length, \t// not just its contents. \t*h = append(*h, x.(int)) } func (h *IntHeap) Pop() any { old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x } Trong nhiá»u trÆ°á»ng há»£p, ta chá»‰ quan tÃ¢m tá»›i kiá»ƒu dá»¯ liá»‡u vÃ  method Less, cÃ²n cÃ¡ch triá»n khai tÆ°Æ¡ng tá»± nhÆ° vÃ­ dá»¥ trÃªn.\nCÃ³ thá»ƒ dÃ¹ng type parameter Ä‘á»ƒ Ä‘Æ¡n giáº£n hÃ³a viá»‡c sá»­ dá»¥ng heap nhÆ° sau:\ntype Heap[T any] struct { data []T lessFunc func(a, b T) bool } func (b *Heap[T]) Len() int { return len(b.data) } func (b *Heap[T]) Less(i, j int) bool { return b.lessFunc(b.data[i], b.data[j]) } func (b *Heap[T]) Swap(i, j int) { tmp := b.data[i] b.data[i] = b.data[j] b.data[j] = tmp } func (b *Heap[T]) Push(x any) { b.data = append(b.data, x.(T)) } func (b *Heap[T]) Pop() any { old := b.data oldLen := len(old) res := old[oldLen-1] b.data = b.data[:oldLen-1] return res } func New[T any](lessFunc func(T, T) bool) *Heap[T] { h := \u0026amp;Heap[T]{ lessFunc: lessFunc, } heap.Init(h) return h } Type parameter cÅ©ng cÃ³ thá»ƒ sá»­ dá»¥ng vá»›i type nhÆ° trong vÃ­ dá»¥ nÃ y. Máº¥u chá»‘t trong cÃ¡ch triá»ƒn khai nÃ y chÃ­nh lÃ  lÆ°u láº¡i lessFunc trong struct Heap, do ta khÃ´ng thá»ƒ thay Ä‘á»•i method Less táº¡i runtime, thay vÃ o Ä‘Ã³ Less sáº½ gá»i vÃ o hÃ m Ä‘Æ°á»£c lÆ°u trong receiver.\nTuy nhiÃªn cÃ³ thá»ƒ tháº¥y ráº±ng kiá»ƒu cá»§a cÃ¡c method nhÆ° Push hay Pop láº¡i lÃ  any vÃ  Ä‘á»ƒ Ä‘áº£m báº£o implement heap.Interface, ta khÃ´ng thá»ƒ sá»­a signature cá»§a cÃ¡c method nÃ y. NgoÃ i ra, viá»‡c gá»i trá»±c tiáº¿p *Heap.Pop thay vÃ¬ heap.Pop(*Heap), vÃ  *Heap.Push(T) thay vÃ¬ heap.Push(*Heap, T) sáº½ gÃ¢y ra káº¿t quáº£ sai, thay vÃ o Ä‘Ã³ nÃªn trÃ¡nh cho phÃ©p gá»i trá»±c tiáº¿p cÃ¡c method nÃ y. Ta sáº½ wrap type mÃ  implement heap interface trong má»™t public Type mÃ  sáº½ nháº­n vÃ  tráº£ vá» káº¿t quáº£ mong muá»‘n:\nChuyá»ƒn triá»ƒn khai trÃªn thÃ nh má»™t unexported struct vá»›i tÃªn base:\ntype base[T any] struct { data []T lessFunc func(a, b T) bool } func (b *base[T]) Len() int { return len(b.data) } func (b *base[T]) Less(i, j int) bool { return b.lessFunc(b.data[i], b.data[j]) } func (b *base[T]) Swap(i, j int) { tmp := b.data[i] b.data[i] = b.data[j] b.data[j] = tmp } func (b *base[T]) Push(x any) { b.data = append(b.data, x.(T)) } func (b *base[T]) Pop() any { old := b.data oldLen := len(old) res := old[oldLen-1] b.data = b.data[:oldLen-1] return res } VÃ  viáº¿t thÃªm má»™t genetic type vá»›i cÃ¡c method mÃ  ta mong muá»‘n:\ntype Heap[T any] struct { base *base[T] } func New[T any](lessFunc func(T, T) bool) *Heap[T] { b := \u0026amp;base[T]{ lessFunc: lessFunc, } heap.Init(b) return \u0026amp;Heap[T]{base: b} } func (h *Heap[T]) Push(t T) { heap.Push(h.base, t) } func (h *Heap[T]) Pop() T { if h.Len() == 0 { // thÃªm validate cho Pop \tvar t T return t } return heap.Pop(h.base).(T) // chuyá»ƒn Ä‘á»•i kiá»ƒu tráº£ vá» cho Ä‘Ãºng } func (h *Heap[T]) Len() int { return h.base.Len() } Cháº¡y thá»­:\nfunc TestGenericHeap(t *testing.T) { data := []int{0, 5, 4, 2, -5, 8, 9, -10} lessFunc := func(i, j int) bool { return j-i \u0026gt; 0 } heap := New(lessFunc) for _, v := range data { heap.Push(v) } for heap.Len() \u0026gt; 0 { fmt.Print(heap.Pop(), \u0026#34; \u0026#34;) } } Káº¿t quáº£:\n-10 -5 0 2 4 5 8 9 Clear hÆ¡n khÃ¡ nhiá»u pháº£i khÃ´ng? CÃ³ thá»ƒ xem code Ä‘áº§y Ä‘á»§ táº¡i Ä‘Ã¢y\n3. Khi nÃ o dÃ¹ng type parameter?  Khi dÃ¹ng type parameter chá»‰ Ä‘á»ƒ gá»i method cá»§a constraints thÃ¬ khÃ´ng nÃªn dÃ¹ng type parameter mÃ  nÃªn dÃ¹ng hÃ m bÃ¬nh thÆ°á»ng nháº­n vÃ o interface. thay vÃ¬  func foo[T io.Writer](w T) { ... w.Write... ... } tá»‘t hÆ¡n lÃ \nfunc foo(w io.Writer) { ... w.Write... ... } nhÆ° cÃ¡ch mÃ  nÃ³ váº«n Ä‘Æ°á»£c viáº¿t tá»« trÆ°á»›c khi go cÃ³ generic.\n VÃ  trong nhiá»u trÆ°á»ng há»£p, viá»‡c sá»­ dá»¥ng type parameter cÃ³ thá»ƒ áº£nh hÆ°á»Ÿng nhiá»u Ä‘áº¿n tÃ­nh dá»… báº£o trÃ¬ cá»§a code, hÃ£y cÃ¢n nháº¯c sá»­ dá»¥ng cÃ¡c phÆ°Æ¡ng phÃ¡p khÃ¡c Ä‘Ã£ nÃªu á»Ÿ pháº§n 1. HÃ£y nhá»› lÃ  go developer váº«n sá»‘ng (khÃ¡) tá»‘t trong má»™t thá»i gian dÃ i mÃ  khÃ´ng cÃ³ generic (â—â€¢á´—â€¢â—)ğŸ‘.  ","permalink":"https://duchoangmanh.github.io/posts/technical/go-gioi-thieu-type-parameter-qua-vi-du/","summary":"1. Kiá»ƒm tra sá»± xuáº¥t hiá»‡n cá»§a má»™t pháº§n tá»­ trong slice Type parameter hay generic lÃ  má»™t tÃ­nh nÄƒng má»›i xuáº¥t hiá»‡n tá»« phiÃªn báº£n 1.18 cá»§a Go. Vá»›i generic, ta cÃ³ thá»ƒ viáº¿t cÃ¡c hÃ m hoáº·c type cÃ³ thá»ƒ dÃ¹ng Ä‘Æ°á»£c cho nhiá»u kiá»ƒu dá»¯ liá»‡u Ä‘áº§u vÃ o khÃ¡c nhau mÃ  khÃ´ng cáº§n pháº£i láº·p láº¡i code nhiá»u láº§n.\nHÃ£y báº¯t Ä‘áº§u vá»›i má»™t vÃ­ dá»¥ Ä‘Æ¡n giáº£n vÃ  phá»• biáº¿n: Kiá»ƒm tra xem string cÃ³ xuáº¥t hiá»‡n trong slice hay khÃ´ng","title":"Go: Giá»›i thiá»‡u vá» type parameter (generic) qua vÃ­ dá»¥"},{"content":"Some Go tips (maybe some dark side too) and notes for writing better code.\n1. Efficiently converse between string and byte slice Gain some performance with the price of maintainability. Using the unsafe package is not advised but we can use it to efficiently converse between a string and byte slice. Use at your own risk.\nbyte slice to string func String(b []byte) (s string) { if len(b) == 0 { return \u0026#34;\u0026#34; } return *(*string)(unsafe.Pointer(\u0026amp;b)) } string to byte slice // mutate the returned slice can cause undefined behavior func ByteSlice(s string) []byte { var b []byte hdr := (*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;b)) hdr.Data = (*reflect.StringHeader)(unsafe.Pointer(\u0026amp;s)).Data hdr.Cap = len(s) hdr.Len = len(s) return b } 2. Change function return value with defer Normally, if we change the returned value with defer, it will not works\nfunc someFunc() int { i := 1 defer func() { i = 2 }() return i } func main() { fmt.Println(someFunc()) // 1 } But with a named return value, defer can change return value of a function\nfunc someFunc() (i int) { i = 1 defer func() { i = 2 }() return i } func main() { fmt.Println(someFunc()) // 2 } 3. Mutate a slice the right way Slice has a pointer to a backing array do not mean that it can be mutated by value\nLet\u0026rsquo;s look at the slice header from reflect package (a runtime representation of a slice but the idea is the same):\ntype SliceHeader struct { Data uintptr // pointer to the underlying array but can change when slice grows  Len int // not safe for mutating via value  Cap int // not safe for mutating via value } Don\u0026rsquo;t\nfunc main() { var s []int mutate(s) fmt.Println(s) // [] } func mutate(s []int) { s = append(s, 1) } Do\nfunc main() { var s []int mutate(\u0026amp;s) fmt.Println(s) // [1] } func mutate(s *[]int) { *s = append(*s, 1) } 4. Check if the any have desired method Sometimes we want to check if a variable of any type has some methods or not, consider using an anonymous interface\nimport \u0026#34;fmt\u0026#34; type Me int func (m Me) Pr() { fmt.Println(m) } func main() { var m any m = Me(1) if callable, ok := m.(interface { Pr() }); ok { // some action when the method exist  } } If the interface is used more than once, better define a proper interface.\n5. Allocate memory for slices in advance We should use the third parameter when making a slice to allocate some memory for that slice to reduce slice grow.\nsomeSlice := make([]int, 0, size) And keep in mind that even if we use a slice with a part of an underlying array, the rest of that array may live in memory much longer than needed, consider copying to a new slice if necessary.\nPre-allocating can be used for maps too!\nsomeMap:= make(map[int]int, size) 6. Efficient String concatenation There\u0026rsquo;s some way to do string concatenation like use + or fmt package\nresult := \u0026#34;hello\u0026#34; + \u0026#34;world\u0026#34; // clean but remember that strings in go are immutable, so not very efficient result := fmt.Sprintf(\u0026#34;%s %s\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;) // use reflect under the hood Instead, consider strings.Builder\nvar b strings.Builder b.WriteString(\u0026#34;hello\u0026#34;) b.WriteString(\u0026#34;world\u0026#34;) result := b.String() In most cases, the difference can be neglected, but if we are doing heavy string concatenation like in a for loop, better use strings.Builder\n7. Channel special behaviors They are well known:\n A send to a nil channel blocks forever A receive from a nil channel blocks forever A send to a closed channel panics A receive from a closed channel returns the zero value immediately  8. Do not copy a sync type sync types shouldnâ€™t be copied. This rule applies to:\n sync.Cond sync.Map sync.Mutex sync.RWMutex sync.Once sync.Pool sync.WaitGroup  9. io.Reader can only be read once Most type that implements the io.Reader interface (os.File, http.Request.Body...) behave like a stream and can only be read once. We can work around this with io.TeeReader that duplicate the stream, but in most case just avoid read an io.Reader a second time.\n10. Always close transient resource Remember to close transient resources to avoid memory leaks. Includes http.Response.Body, sql.Rows, os.File and more\n","permalink":"https://duchoangmanh.github.io/posts/technical/go-tips-and-optimization-notes/","summary":"Some Go tips (maybe some dark side too) and notes for writing better code.\n1. Efficiently converse between string and byte slice Gain some performance with the price of maintainability. Using the unsafe package is not advised but we can use it to efficiently converse between a string and byte slice. Use at your own risk.\nbyte slice to string func String(b []byte) (s string) { if len(b) == 0 { return \u0026#34;\u0026#34; } return *(*string)(unsafe.","title":"Go tips and optimization notes"},{"content":"This post contains my notes while implement caneweb - a gin-like minimal web framework/router after reading the first section of 7 days golang by geektutu (https://github.com/geektutu/7days-golang).\nHow standard net/http package handle request? First, let\u0026rsquo;s look at a sample written with net/http package:\nfunc main() { http.HandleFunc(\u0026#34;/\u0026#34;, handler) http.HandleFunc(\u0026#34;/post\u0026#34;, getAllPost) log.Fatal(http.ListenAndServe(\u0026#34;localhost:8000\u0026#34;, nil)) } func handler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;URL.Path = %q\\n\u0026#34;, r.URL.Path) } This piece of code binds two endpoints with the corresponding handler function, and starts a web server at port 8000, terminates the server if some errors are returned.\nAll http handlers must implement the handler interface, and we can use multiple handlers to handle a single request by passing the parameters around:\ntype Handler interface { ServeHTTP(ResponseWriter, *Request) } The standard library package does provide basic functions to create a web server including monitor port, static routing, request parsing\u0026hellip; Some other functions need to be implemented when necessary:\n Dynamic routing: routing with rules like post/:id, post/*,\u0026hellip; or using regular expression. Middleware: By passing around the request, and response between multiple functions to change the result. Group requests: Group endpoints into a cluster that share some commons. Validate requests. \u0026hellip;  Create the static-routing version of the framework First, we need to design a struct that represents the state of the current request data and have methods to easily work with requests.\nWhy encapsulate response and request into a single struct?  Reduce the complexity of the handler, a user no longer need to care about which data resides in request, or responseWriter Easier to create a response and less error-prone, reduce repetitive  For example, in order to write the response for a request, instead of\nobj = map[string]interface{}{ \u0026#34;title\u0026#34;: \u0026#34;my first blog post\u0026#34;, \u0026#34;read_time\u0026#34;: \u0026#34;5\u0026#34;, } w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) w.WriteHeader(http.StatusOK) encoder := json.NewEncoder(w) if err := encoder.Encode(obj); err != nil { http.Error(w, err.Error(), 500) } We can achive the same result in a simpler and clearer way:\nc.JSON(http.StatusOK, cane.Map{ \u0026#34;title\u0026#34;: \u0026#34;my first blog post\u0026#34;, \u0026#34;read_time\u0026#34;: 5, }) ctx.go\npackage cane import \u0026#34;net/http\u0026#34; type Ctx struct { // origin objects  Writer http.ResponseWriter Req *http.Request // request data  Path string Method string // response data  StatusCode int } // newCtx create new Ctx with original data func newCtx(w http.ResponseWriter, r *http.Request) *Ctx { return \u0026amp;Ctx{ Writer: w, Req: r, Path: r.URL.Path, Method: r.Method, } } Add some functions to work with request and reponse morre efficiently:\n// responseWriter func (c *Ctx) SetHeader(key, value string) { c.Writer.Header().Set(key, value) } func (c *Ctx) Status(code int) { c.StatusCode = code c.Writer.WriteHeader(code) } func (c *Ctx) String(code int, formatString string, values ...interface{}) { c.SetHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/plain\u0026#34;) c.Status(code) _, err := fmt.Fprintf(c.Writer, formatString, values...) if err != nil { http.Error(c.Writer, err.Error(), http.StatusInternalServerError) } } func (c *Ctx) JSON(code int, data interface{}) { c.SetHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) c.Status(code) encoder := json.NewEncoder(c.Writer) err := encoder.Encode(data) if err != nil { http.Error(c.Writer, err.Error(), http.StatusInternalServerError) } } func (c *Ctx) HTML(code int, html string) { c.SetHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/html\u0026#34;) c.Status(code) _, err := c.Writer.Write([]byte(html)) if err != nil { http.Error(c.Writer, err.Error(), http.StatusInternalServerError) } } // request func (c *Ctx) FormValue(key string) string { return c.Req.FormValue(key) } func (c *Ctx) Query(key string) string { return c.Req.URL.Query().Get(key) } Our handler interface should look like this:\ntype Handler interface { Serve(c *Ctx) } Instead of creating a struct for each handler, we can use an adapter to use a function for a simple task, like in the standard net/http package:\ntype HandleFunc func(c *Ctx) func (f HandleFunc) Serve(c *Ctx) { f(c) } The static-routing router Now, we need an object to keep all our static routing configurations and decide which handler to use with each URL and method a.k.a router In this first version of the web framework, I simply use a map to represent the router with static routing:\nrouter.go\ntype router struct { handlers map[string]Handler } func newRouter() *router { return \u0026amp;router{ handlers: make(map[string]Handler), } } // create route from method and path func getRoute(method, path string) (route string) { var builder strings.Builder fmt.Fprintf(\u0026amp;builder, \u0026#34;%s%s%s\u0026#34;, method, \u0026#34;-\u0026#34;, path) route = builder.String() return } // add a new route to the router func (r *router) addRoute(method, path string, handler Handler) { log.Printf(\u0026#34;add route %s %s\u0026#34;, method, path) route := getRoute(method, path) r.handlers[route] = handler } //route request to appropriate handler, error code if no handler found func (r *router) handle(c *Ctx) { route := getRoute(c.Method, c.Path) if handler, ok := r.handlers[route]; ok { handler.Serve(c) } else { c.Writer.WriteHeader(http.StatusNotFound) c.String(http.StatusNotFound, \u0026#34;No route found\u0026#34;) } } Create the interface of caneweb Lastly, we need a layer for the user to work with the web framework, by hiding the internal implementation of the router and such.\ntype Engine struct { router *router } // constructor of cane web framework func New() *Engine { return \u0026amp;Engine{ router: newRouter(), } } func (e *Engine) addRoute(method, pattern string, handler Handler) { e.router.addRoute(method, pattern, handler) } // define some simple operations func (e *Engine) GET(pattern string, handler Handler) { e.addRoute(http.MethodGet, pattern, handler) } func (e *Engine) POST(pattern string, handler Handler) { e.addRoute(http.MethodPost, pattern, handler) } // implement the standard package Handler interface // and transform incoming request to our handler func (e *Engine) ServeHTTP(w http.ResponseWriter, r *http.Request) { ctx := newCtx(w, r) e.router.handle(ctx) } func (e *Engine) Run(addr string) error { return http.ListenAndServe(addr, e) } Create a simple server with the framework main.go\npackage main import ( \u0026#34;caneweb/cane\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { server := cane.New() server.GET(\u0026#34;/hello\u0026#34;, cane.HandleFunc(hello)) server.POST(\u0026#34;/post\u0026#34;, cane.HandleFunc(createPost)) log.Fatal(server.Run(\u0026#34;:5445\u0026#34;)) } func hello(c *cane.Ctx) { c.String(http.StatusOK, \u0026#34;hello %s\u0026#34;, c.Query(\u0026#34;name\u0026#34;)) } func createPost(c *cane.Ctx) { title := c.FormValue(\u0026#34;title\u0026#34;) desc := c.FormValue(\u0026#34;desc\u0026#34;) c.JSON(http.StatusOK, cane.Map{ \u0026#34;post_title\u0026#34;: title, \u0026#34;description\u0026#34;: desc, }) } Send requests to the web server with curl.\ncurl \u0026#34;127.0.0.1:5445/hello?name=duchm\u0026#34; hello duchm curl \u0026#34;http://localhost:5445/post\u0026#34; -X POST -d \u0026#39;title=\u0026#34;first post\u0026#34;\u0026amp;desc=\u0026#34;rainny day\u0026#34;\u0026#39; {\u0026#34;description\u0026#34;:\u0026#34;\\\u0026#34;rainny day\\\u0026#34;\u0026#34;,\u0026#34;post_title\u0026#34;:\u0026#34;\\\u0026#34;first post\\\u0026#34;\u0026#34;} curl \u0026#34;127.0.0.1:5445/any\u0026#34; No route found That\u0026rsquo;s it, after this, we have implemented the prototype version of caneweb framework in go. Currently, the framework does nothing more than the standard net/http package but worry not, some other nice features will be added in the next versions.\nSee the source code at https://github.com/DucHoangManh/caneweb\n","permalink":"https://duchoangmanh.github.io/posts/technical/create-a-web-framework-in-go/","summary":"This post contains my notes while implement caneweb - a gin-like minimal web framework/router after reading the first section of 7 days golang by geektutu (https://github.com/geektutu/7days-golang).\nHow standard net/http package handle request? First, let\u0026rsquo;s look at a sample written with net/http package:\nfunc main() { http.HandleFunc(\u0026#34;/\u0026#34;, handler) http.HandleFunc(\u0026#34;/post\u0026#34;, getAllPost) log.Fatal(http.ListenAndServe(\u0026#34;localhost:8000\u0026#34;, nil)) } func handler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;URL.Path = %q\\n\u0026#34;, r.URL.Path) } This piece of code binds two endpoints with the corresponding handler function, and starts a web server at port 8000, terminates the server if some errors are returned.","title":"Create a web framework in Go part 1: static routing"},{"content":"Táº¡i sao láº¡i cÃ³ bÃ i viáº¿t nÃ y?: Design pattern: Nhá»¯ng giáº£i phÃ¡p cÃ³ thá»ƒ tÃ¡i sá»­ dá»¥ng cho cÃ¡c váº¥n Ä‘á» thÆ°á»ng gáº·p táº¡i má»™t ngá»¯ cáº£nh nháº¥t Ä‘á»‹nh trong quÃ¡ trinh thiáº¿t káº¿ pháº§n má»m.\nBÃ i viáº¿t nÃ y nÃ³i vá» má»™t sá»‘ Design pattern \u0026ldquo;thÃ¢n thiá»‡n\u0026rdquo; hÆ¡n trong go, Ä‘Æ°á»£c mÃ¬nh tá»•ng há»£p dá»±a trÃªn buá»•i talk cá»§a Ryan Djurovich (https://www.youtube.com/watch?v=HHqv3_rUr88) vÃ  má»™t sá»‘ nguá»“n tÃ i liá»‡u khÃ¡c mÃ  mÃ¬nh Ä‘á»c Ä‘Æ°á»£c.\nFactory pattern Khá»i pháº£i nÃ³i vá» Ä‘á»™ phá»• biáº¿n cá»§a nÃ³ rá»“i, ráº¥t há»¯u Ã­ch khi cáº§n pháº£i khá»Ÿi táº¡o má»™t Ä‘á»‘i tÆ°á»£ng cÃ³ nhiá»u triá»ƒn khai (concrete types), phÃ­a client chá»‰ cáº§n quan tÃ¢m Ä‘áº¿n cÃ¡c method, Factory sáº½ lo viá»‡c lá»±a chá»n triá»ƒn khai nÃ o sáº½ Ä‘Æ°á»£c dÃ¹ng Ä‘á»ƒ xá»­ lÃ½ dá»¯ liá»‡u.\n// use Stringer as the interface  type ErrPrint struct{} func (p *ErrPrint) String() string { return \u0026#34;some error happens\u0026#34; } type InfoPrint struct{} func (p *InfoPrint) String() string { return \u0026#34;nothing dramatically happens\u0026#34; } func NewPrinter(kind string) (result fmt.Stringer, err error) { switch kind { case \u0026#34;error\u0026#34;: result = \u0026amp;ErrPrint{} case \u0026#34;info\u0026#34;: result = \u0026amp;InfoPrint{} default: err = errors.New(\u0026#34;invalid kind\u0026#34;) } return } Decorator (Functional option) Äá»ƒ nÃ³i vá» pattern nÃ y, Ä‘áº§u tiÃªn hÃ£y xem vÃ­ dá»¥ bÃªn dÆ°á»›i:\nfunc runServer() { http.HandleFunc(\u0026#34;/\u0026#34;, helloEndpoint) log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil)) } func helloEndpoint(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;Hello world\u0026#34;) } Äoáº¡n code trÃªn táº¡o ra má»™t web server Ä‘Æ¡n giáº£n vá»›i net/http package vá»›i má»™t endpoint duy nháº¥t. BÃ i toÃ¡n Ä‘Æ°á»£c Ä‘áº·t ra lÃ  bÃ¢y giá» cáº§n log láº¡i thá»i gian cáº§n Ä‘á»ƒ hoÃ n táº¥t xá»­ lÃ½ request. Äá»ƒ gia tÄƒng tÃ­nh tÃ¡i sá»­ dá»¥ng, trÃ¡nh pháº£i sá»­a láº¡i handler, cÅ©ng nhÆ° dá»… dÃ ng báº£o trÃ¬ vá» sau, ta cÃ³ thá»ƒ viáº¿t nhÆ° sau:\nfunc runServer() { http.HandleFunc(\u0026#34;/\u0026#34;, durationLogger(helloEndpoint)) log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil)) } func helloEndpoint(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;Hello world\u0026#34;) } func durationLogger(f http.HandlerFunc) http.HandlerFunc { return func(writer http.ResponseWriter, request *http.Request) { startTime := time.Now() f(writer, request) log.Printf(\u0026#34;complete handle request after %s ms\u0026#34;, time.Since(startTime).Milliseconds()) } } NhÆ° váº­y, chÃºng ta cÃ³ thá»ƒ dá»… dÃ ng thÃªm tÃ­nh nÄƒng log thá»i gian nÃ y vÃ o nhá»¯ng handler cáº§n thiáº¿t, viá»‡c thay Ä‘á»•i ná»™i dung log cÅ©ng trá»Ÿ nÃªn dá»… dÃ ng hÆ¡n. ÄÃ¢y chá»‰ lÃ  má»™t vÃ­ dá»¥ Ä‘Æ¡n giáº£n vá» middleware, trong thá»±c táº¿ viá»‡c triá»ƒn khai cÃ³ thá»ƒ phá»©c táº¡p hÆ¡n Ä‘á»ƒ phÃ¹ há»£p vá»›i cÃ¡c nhÃ¹ cáº§u khÃ¡c nhau.\nIterator Táº¡i sao láº¡i cáº§n pattern nÃ y thay vÃ¬ duyá»‡t (array, slice, map, channel\u0026hellip;) trong go?\n CÃ³ thá»ƒ káº¿t há»£p vá»›i decorator Khi viáº¿t má»™t module nÃ o Ä‘Ã³ mÃ  muá»‘n che giáº¥u triá»ƒn khai bÃªn dÆ°á»›i, chá»‰ cho phÃ©p phÃ­a sá»­ dá»¥ng duyá»‡t tuáº§n tá»± cÃ¡c pháº§n tá»­. VÃ­ dá»¥ io.Reader, sql/database.Row  type Iterator struct { tasks []string position int } // Next will return the next task in the slice // if there\u0026#39;s more data to iterate, more will be true func (t *Iterator) Next() (pos int, val string, more bool) { t.position++ if t.position \u0026gt; len(t.tasks) { return t.position, \u0026#34;\u0026#34;, false } return t.position, t.tasks[t.position-1], true } TrÃªn Ä‘Ã¢y lÃ  má»™t vÃ­ dá»¥ Ä‘Æ¡n giáº£n vá» triá»ƒn khai iterator trong go\nfor _, val, more := i.Next(); more; _, val, more = i.Next() { fmt.Println(val) } Dependency Injection DI trong go cÃ³ thá»ƒ Ä‘Æ°á»£c triá»ƒn khai theo nhiá»u cÃ¡ch, cÃ³ cáº£ nhá»¯ng thÆ° viá»‡n chuyÃªn dÃ¹ng Ä‘á»ƒ DI trong go (google/wire, uber-go/fx), trong bÃ i viáº¿t nÃ y sáº½ chá»‰ nÃ³i vá»ƒ cÃ¡ch triá»ƒn khai Ä‘Æ¡n giáº£n nháº¥t\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Client package â”‚ Client â”œâ”€â”€â”€â”€â”€â–º \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; â”‚ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ Client Service Interface â”‚ â”‚ â”‚ â””â”€â”€â”€â”€â”€â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â”‚ â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€|â”€â”€â”€â”€â”€â”¼â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”¤ â”‚ Service package â”‚ Concrete Service 1 â”‚ â”‚Concrete Service 2â”‚ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â”‚ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ ÄÃ¢y lÃ  má»™t Ä‘oáº¡n code vÃ­ dá»¥ co dependency injection sá»­ dá»¥ng constructor\nfunc main() { s := NewMyService(os.Stderr) s.WriteHello(\u0026#34;world\u0026#34;) } type MyService struct { writer io.Writer } func NewMyService(writer io.Writer) MyService { return MyService{ writer: writer, } } func (s *MyService) WriteHello(m string) { fmt.Fprintf(s.writer, \u0026#34;Hello %s\\n\u0026#34;, m) } ThÃªm method Ä‘á»ƒ cÃ³ thá»ƒ sá»­ dá»¥ng setter injection:\nfunc (s *MyService) SetWriter(w io.Writer) { s.writer = w } So sÃ¡nh hai cÃ¡ch:\n constructor: Äáº£m báº£o dependency Ä‘Æ°á»£c sá»­ dá»¥ng luÃ´n valid setter: CÃ³ thá»ƒ thay tháº¿ concrete service trong quÃ¡ trÃ¬nh cháº¡y chÆ°Æ¡ng trÃ¬nh(runtime)  Repository Má»™t pattern trong thiáº¿t káº¿ pháº§n máº¿m hÆ°á»›ng tá»›i viá»‡c tiáº¿n hÃ³a lÃ¢u dÃ i cá»§a á»©ng dá»¥ng, cÃ¡c module phá»¥ thuá»™c cÃ³ thá»ƒ Ä‘Æ°á»£c thay Ä‘á»•i trong tÆ°Æ¡ng lai. VÃ­ dá»¥ dÆ°á»›i Ä‘á» thá»ƒ hiá»‡n viá»‡c triá»ƒn khai má»™t á»©ng dá»¥ng mÃ  lá»›p storage cÃ³ thá»ƒ Ä‘Æ°á»£c thay Ä‘á»•i: package post - khai bÃ¡o model\ntype Post struct { ID int64 Title string } package domain - khai bÃ¡o cÃ¡c interface client sá»­ dá»¥ng Ä‘á»ƒ thao tÃ¡c vá»›i storage\n// Repository must be implemented by all implementations of Post storage type Repository interface { FindAll() ([]post.Post, error) Store(post post.Post) (post.Post, error) DeleteById(postId int64) error } package memstorage - má»™t triá»ƒn khai cá»§a storage\n//in-memory implementation type PostStorage struct { posts map[int64]string highestID int64 } func (p *PostStorage) FindAll() ([]post.Post, error) { result := make([]post.Post, 0) for id, title := range p.posts { result = append(result, post.Post{ ID: id, Title: title, }) } return result, nil } func (p *PostStorage) Store(post post.Post) (post.Post, error) { if p.posts == nil { p.posts = make(map[int64]string) } if post.ID \u0026lt;= 0 { p.highestID++ post.ID = p.highestID } else { if _, exists := p.posts[post.ID]; !exists { return post, fmt.Errorf(\u0026#34;post already exist\u0026#34;) } } p.posts[post.ID] = post.Title return post, nil } func (p *PostStorage) DeleteById(postId int64) error { delete(p.posts, postId) return nil } Sá»­ dá»¥ng repository package: package main\nfunc main() { postRepo := memstorage.PostStorage{} //may change to other implementation in the future \tnewPost, err := postRepo.Store(post.Post{ Title: \u0026#34;Eagles fly\u0026#34;, }) if err != nil { log.Println(\u0026#34;can not create post\u0026#34;, err) } else { log.Printf(\u0026#34;created post with id %d\u0026#34;, newPost.ID) } posts, err := postRepo.FindAll() if err != nil { log.Println(\u0026#34;can not fetch posts\u0026#34;, err) } else { log.Println(posts) } } Báº±ng cÃ¡ch chia nhá» viá»‡c triá»ƒn khai, domain interface vÃ  model, trong trÆ°á»ng há»£p má»™t pháº§n má»m cáº§n thay tháº¿ cÃ¡c module trong tÆ°Æ¡ng lai, cÃ³ thá»ƒ update má»™t cÃ¡ch dá»… dÃ ng.\nMÃ£ nguá»“n trong bÃ i viáº¿t cÃ³ thá»ƒ xem táº¡i: https://github.com/DucHoangManh/go-patterns\n","permalink":"https://duchoangmanh.github.io/posts/technical/design-pattern-than-thien-trong-go/","summary":"Táº¡i sao láº¡i cÃ³ bÃ i viáº¿t nÃ y?: Design pattern: Nhá»¯ng giáº£i phÃ¡p cÃ³ thá»ƒ tÃ¡i sá»­ dá»¥ng cho cÃ¡c váº¥n Ä‘á» thÆ°á»ng gáº·p táº¡i má»™t ngá»¯ cáº£nh nháº¥t Ä‘á»‹nh trong quÃ¡ trinh thiáº¿t káº¿ pháº§n má»m.\nBÃ i viáº¿t nÃ y nÃ³i vá» má»™t sá»‘ Design pattern \u0026ldquo;thÃ¢n thiá»‡n\u0026rdquo; hÆ¡n trong go, Ä‘Æ°á»£c mÃ¬nh tá»•ng há»£p dá»±a trÃªn buá»•i talk cá»§a Ryan Djurovich (https://www.youtube.com/watch?v=HHqv3_rUr88) vÃ  má»™t sá»‘ nguá»“n tÃ i liá»‡u khÃ¡c mÃ  mÃ¬nh Ä‘á»c Ä‘Æ°á»£c.","title":"Design pattern thÃ¢n thiá»‡n trong go"}]