[{"content":"Go 1.22 has just been released with a bunch of new features and improvements. In this article, we will explore the new loop semantics and how they can be used to write more expressive and readable code.\n1. Loop variable is no longer be shared between iterations Previously, the loop variable was shared between iterations, from go 1.21 (experimental) and now with go 1.22, the loop variable is created anew with each iteration, effectively eliminating one of the most common foot gun in Go (for both experienced and new gophers). This is no longer needed:\nfor i := 0; i \u0026lt; 10; i++ { i := i go func () { fmt.Println(i) }() } or this\nfor i := 0; i \u0026lt; 10; i++ { go func (i int) { fmt.Println(i) }(i) } now you can do the more intuitive way:\nfor i := 0; i \u0026lt; 10; i++ { go func () { fmt.Println(i) }() } 2. Range over an integer This feature is straightforward, instead of\nfor i := 0; i \u0026lt; 10; i++ { fmt.Println(i) } now you can do\nfor i := range 10 { fmt.Println(i) } and achieve the same result, pretty neat, right?\n3. Range over a function In my humble opinion, this is one of the most exciting updates to the Go language in a long time. Now Go have a standard way to handle iterator, which is a common pattern in other languages.\nWith preceding go versions, there wasn\u0026rsquo;t a standard way to iterate through a data structure, generic is not yet available in the language so, you couldn\u0026rsquo;t write a simple iterator for different data structures.\nbufio.Scanner is an iterator through an io.Reader, where the Scan method advances to the next value. The value is returned by a Bytes method. Errors are collected and returned by an Err method. database/sql.Rows iterates through the results of a database query, where the Next method advances to the next row and the value is returned by a Scan method which can return an error. Let\u0026rsquo;s have a look at the new loop semantics in action: please note that despite this feature is available in go 1.22, it\u0026rsquo;s still experimental and may change in the future, plus you have to build your program using GOEXPERIMENT=rangefunc\n// iterate from 0 to 9 In10 := func(yield func(int) bool) { for i := range 10 { if !yield(i) { return } } } for v := range In10 { fmt.Println(v) // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } In10 is a function that takes a function yield as an argument. The yield function takes an integer and returns a boolean, whenever In10 is used, the loop body will specify the yield function, and the In10 function will call the yield function with the current value of the loop variable. You can easily see that the yield function have a signature that return a bool but the loop body itself does not return anything, this is because inside the loop body, continue or nothing will be translated to return true and break will be translated to return false. Give the user the ability to control the iteration from the loop body. The compiler will change the for over function to something that looks like this:\nInt10(func(i int) bool { fmt.Println(i) return true }) this explanation is somewhat oversimplified, the actual implementation is more complex, you can find more about it here Besides the one parameter yield function mentioned above, functions that can be ranged over can have zero or two parameters, as long as they have the following signature:\npackage iter type Seq0 func(yield func() bool) bool type Seq[V any] func(yield func(V) bool) bool type Seq2[K, V any] func(yield func(K, V) bool) bool More examples:\n// iterate over a specific range with start and end value InRange := func(start, end int) func(yield func(int) bool) { return func(yield func(int) bool) { for i := start; i \u0026lt; end; i++ { if !yield(i) { return } } } } for x := range InRange(5, 10) { fmt.Println(x) // 5, 6, 7, 8, 9 } // iterate over words in a string separated by space Words := func(s string) func(yield func(int, string) bool) { words := strings.Split(s, \u0026#34; \u0026#34;) return func(yield func(int, string) bool) { for i, word := range words { if !yield(i, word) { return } } } } for i, word := range Words(\u0026#34;sun rises in the east\u0026#34;) { fmt.Println(i, word) // 0 sun 1 rises 2 in 3 the 4 east } usually, while using some polling based library, you have to write a loop like this:\nfor { m, err := reader.ReadMessage(context.Background()) if err != nil { // handle error continue } // handle message }\tyou can leverage the new loop semantics to write a more expressive message poller:\nReaderIterator := func (reader Reader) func (func (Message, error) bool) { return func (yield func (Message, error) bool) { for { m, err := reader.ReadMessage(context.Background()) if !yield(m, err) { break } } } } for message err := range ReaderIterator(reader) { if err != nil { // handle error } // handle message } Pull iterator All the examples above are push iterators, pushing values to the yield function. But that is not always the case in the real world, sometimes you want to pull values from the iterator.\nThe Pull function from iter package converse a Seq- standard push iterator to a pull iterator. Calling Pull will start an iteration and returns a pair of functions next and stop, which return the next value from the iterator and stop it, respectively.\nInRange := func(start, end int) func(yield func(int) bool) { return func(yield func(int) bool) { for i := start; i \u0026lt; end; i++ { if !yield(i) { return } } } } next, stop := iter.Pull(InRange(5, 7)) defer stop() for value, more := next(); more; value, more = next() { fmt.Println(value) // 5, 6 } The new loop semantics surely is a great addition to the Go language as it opens the door for more idiomatic APIs with range functions.\nReferences: Go 1.22 Release Notes spec: add range over int, range over func iter: new package for iterators Go Wiki: Rangefunc Experiment ","permalink":"https://duchoangmanh.github.io/posts/technical/exploring-go-new-loop-semantics/","summary":"Go 1.22 has just been released with a bunch of new features and improvements. In this article, we will explore the new loop semantics and how they can be used to write more expressive and readable code.\n1. Loop variable is no longer be shared between iterations Previously, the loop variable was shared between iterations, from go 1.21 (experimental) and now with go 1.22, the loop variable is created anew with each iteration, effectively eliminating one of the most common foot gun in Go (for both experienced and new gophers).","title":"Go: Exploring new loop semantics"},{"content":"The significance of integration testing in assuring the reliability and seamless operation of software systems cannot be understated. This guide will help you get started with using containers for integration testing and learn how to set up and execute test cases effectively.\nLet\u0026rsquo;s consider a small example program where I use postgres as the underlying database to store product records:\ncreate table product ( id serial8 not null primary key, name varchar(100) not null, type varchar(50) not null, code varchar(50) not null, price int4 not null ); The program can create, update and list products via a repository:\ntype Product struct { ID int64 `db:\u0026#34;id\u0026#34;` Name string `db:\u0026#34;name\u0026#34;` Type string `db:\u0026#34;type\u0026#34;` Code string `db:\u0026#34;code\u0026#34;` Price int64 `db:\u0026#34;price\u0026#34;` } ... type ProductPersistenceRepository struct { db *sqlx.DB } func (r *ProductPersistenceRepository) Create(product Product) (Product, error) { created := Product{} rows, err := r.db.NamedQuery( \u0026#34;INSERT INTO product (name, type, code, price) VALUES (:name, :type, :code, :price) RETURNING *\u0026#34;, product, ) if err != nil { return created, fmt.Errorf(\u0026#34;ProductPersistenceRepository Create: %w\u0026#34;, err) } for rows.Next() { if err := rows.StructScan(\u0026amp;created); err != nil { return created, fmt.Errorf(\u0026#34;ProductPersistenceRepository Create: %w\u0026#34;, err) } } return created, nil } ... // update and list functions To test these functions against a real database, we\u0026rsquo;ll need a clean database instance.\nWith a bit of research, we can find that starting and cleaning up containerized dependencies can be done with ease by running database within a container as part of the test itself.\nI have come across some libraries that help to effectively spin up testing container, such as dockertest or testcontainer, which I will utilize in this guide. To begin, let\u0026rsquo;s write some code that runs a postgres container and returns the container address and port for later connection.\nfunc NewTestDatabase(t *testing.T) (string, string) { ctx, cancel := context.WithTimeout(context.Background(), time.Minute) defer cancel() req := testcontainers.ContainerRequest{ Image: \u0026#34;postgres:12\u0026#34;, ExposedPorts: []string{\u0026#34;5432/tcp\u0026#34;}, HostConfigModifier: func(config *container.HostConfig) { config.AutoRemove = true }, Env: map[string]string{ \u0026#34;POSTGRES_USER\u0026#34;: \u0026#34;denishoang\u0026#34;, \u0026#34;POSTGRES_PASSWORD\u0026#34;: \u0026#34;pgpassword\u0026#34;, \u0026#34;POSTGRES_DB\u0026#34;: \u0026#34;products\u0026#34;, }, WaitingFor: wait.ForListeningPort(\u0026#34;5432/tcp\u0026#34;), } postgres, err := testcontainers.GenericContainer( ctx, testcontainers.GenericContainerRequest{ ContainerRequest: req, Started: true, }, ) require.NoError(t, err) mappedPort, err := postgres.MappedPort(ctx, \u0026#34;5432\u0026#34;) require.NoError(t, err) hostIP, err := postgres.Host(ctx) require.NoError(t, err) return hostIP, mappedPort.Port() } The function above runs a postgres container like you normally do with docker cli by interacting with the docker api.\nNotice the request\u0026rsquo;s param WaitingFor: wait.ForListeningPort(\u0026quot;5432/tcp\u0026quot;), with this configuration, our tests will check if the container is listening to a specific port (5432/tcp in this case) before proceeding to the next part, makes sure that the database is ready before performing any tests. You can take a look at other wait strategies supported by testcontainer here.\nThis way, we can spin up a clean database for each test and remove it after the test is done.\nLet\u0026rsquo;s get our hands dirty with the integration test, we\u0026rsquo;ll use the address and port returned from the NewTestDatabase function to connect to the database and perform the tests.\nfunc Test_Product(t *testing.T) { host, port := NewTestDatabase(t) db, err := sqlx.Connect( \u0026#34;postgres\u0026#34;, fmt.Sprintf( \u0026#34;postgres://denishoang:pgpassword@%s:%s/products?sslmode=disable\u0026#34;, host, port, ), ) require.Nil(t, err) repo := repository.NewProductPersistenceRepository(db) t.Run( \u0026#34;test create product\u0026#34;, func(t *testing.T) { created, err := repo.Create( repository.Product{ Name: \u0026#34;cake\u0026#34;, Type: \u0026#34;food\u0026#34;, Code: \u0026#34;c1\u0026#34;, Price: 100, }, ) require.Nil(t, err) require.Equal(t, \u0026#34;cake\u0026#34;, created.Name) }, ) } try to run the test, and you\u0026rsquo;ll see in the logs that the postgres container is being created and started, and the test is being executed.\n‚úÖ Container created: ec1c30ac431b üê≥ Starting container: ec1c30ac431b ‚úÖ Container started: ec1c30ac431b üöß Waiting for container id ec1c30ac431b image: postgres:12. Waiting for: \u0026amp;{Port:5432/tcp timeout:\u0026lt;nil\u0026gt; PollInterval:100ms} then the test failed, is there something wrong?\n=== RUN Test_Product/test_create_product product_test.go:34: Error Trace:\tproduct_test.go:34 Error: Expected nil, but got: \u0026amp;fmt.wrapError{msg:\u0026#34;ProductPersistenceRepository Create: pq: relation \\\u0026#34;product\\\u0026#34; does not exist\u0026#34;, err:(*pq.Error)(0x14000442b40)} Test: Test_Product/test_create_product --- FAIL: Test_Product/test_create_product (0.00s) The error message tells us that the table product does not exist, since we are using a clean database, it\u0026rsquo;s necessary to perform some migrations before running the test.\nI\u0026rsquo;m using golang-migrate to do the migrations, this involves placing all the migration files in a directory and applying them before the tests.\n//go:embed \u0026#34;migrations\u0026#34; var EmbeddedFiles embed.FS package persistence func MigrationUp(completeDsn string) error { iofsDriver, err := iofs.New(EmbeddedFiles, \u0026#34;migrations\u0026#34;) if err != nil { return err } migrator, err := migrate.NewWithSourceInstance(\u0026#34;iofs\u0026#34;, iofsDriver, completeDsn) if err != nil { return err } return migrator.Up() } use this function after the database is ready:\nfunc NewTestDatabase(t *testing.T) (string, string) { ... err = persistence.MigrationUp( fmt.Sprintf( \u0026#34;postgres://denishoang:pgpassword@%s:%s/products?sslmode=disable\u0026#34;, hostIP, mappedPort.Port(), ), ) require.NoError(t, err) return hostIP, mappedPort.Port() } Now, the test should pass.\nHowever, there are still some things to consider: We don\u0026rsquo;t really need an entire database instance for each test as it can be resource-consuming and unnecessary.\nIdeally, we can reuse the previously created database instance and create a new database for each test.\nLet\u0026rsquo;s rewrite the NewTestDatabase function, instead of directly return the address and port of the database instance, we just create a new database instance that can be reused later.\nvar postgresContainer testcontainers.Container func StartDatabase() { ctx, cancel := context.WithTimeout(context.Background(), time.Minute) defer cancel() req := testcontainers.ContainerRequest{ Image: \u0026#34;postgres:12\u0026#34;, ExposedPorts: []string{\u0026#34;5432/tcp\u0026#34;}, HostConfigModifier: func(config *container.HostConfig) { config.AutoRemove = true }, Env: map[string]string{ \u0026#34;POSTGRES_USER\u0026#34;: \u0026#34;denishoang\u0026#34;, \u0026#34;POSTGRES_PASSWORD\u0026#34;: \u0026#34;pgpassword\u0026#34;, \u0026#34;POSTGRES_DB\u0026#34;: \u0026#34;products\u0026#34;, }, WaitingFor: wait.ForListeningPort(\u0026#34;5432/tcp\u0026#34;), } postgres, err := testcontainers.GenericContainer( ctx, testcontainers.GenericContainerRequest{ ContainerRequest: req, Started: true, }, ) if err != nil { os.Exit(1) } postgresContainer = postgres } And a function to create a new database for each test:\nfunc NewDatabase(t *testing.T) *sqlx.DB { ctx := context.Background() if postgresContainer == nil { t.Fatal(\u0026#34;postgres is not yet started\u0026#34;) } mappedPort, err := postgresContainer.MappedPort(ctx, \u0026#34;5432\u0026#34;) if err != nil { t.Fatal(\u0026#34;err get mapped port from container\u0026#34;) } hostIP, err := postgresContainer.Host(ctx) // open connection to postgres instance in order to create other databases baseDb, err := sqlx.Open( \u0026#34;postgres\u0026#34;, fmt.Sprintf( \u0026#34;postgres://denishoang:pgpassword@%s:%s/products?sslmode=disable\u0026#34;, hostIP, mappedPort.Port(), ), ) defer func() { if err := baseDb.Close(); err != nil { t.Fatal(\u0026#34;err close connection to db\u0026#34;) } }() // a naive scheme to generate random database names dbName := fmt.Sprintf(\u0026#34;%s_%d\u0026#34;, \u0026#34;products\u0026#34;, rand.Int63()) if _, err := baseDb.Exec(fmt.Sprintf(\u0026#34;CREATE DATABASE %s;\u0026#34;, dbName)); err != nil { t.Fatal(\u0026#34;err creating postgres database\u0026#34;) } connString := fmt.Sprintf( \u0026#34;postgres://denishoang:pgpassword@%s:%s/%s?sslmode=disable\u0026#34;, hostIP, mappedPort.Port(), dbName, ) // apply migrations to the newly created database if err = persistence.MigrationUp(connString); err != nil { t.Fatal(\u0026#34;err connect postgres database\u0026#34;) } // connect to new database db, err := sqlx.Open(\u0026#34;postgres\u0026#34;, connString) if err != nil { t.Fatal(\u0026#34;err connect postgres database\u0026#34;) } return db } As you can see, there is quite a bit happening here; let me explain:\nWe have started the postgres container in the StartDatabase function, and stored the container instance in a global variable. The NewDatabase function will create a new database for each test, by connecting to the postgres instance and creating a new database with a random name. It then applies migrations to the new database and returns the connection to the new database. The test that calls NewDatabase function will have its own database so, there is no need to worry about cleaning up the database after each test. Another positive aspect is that our tests can run in parallel without any issues. But we still have a problem, how to run StartDatabase before any tests?\nLuckily, go\u0026rsquo;s build in test utility provides the TestMain function, which allows us to run some setup code before or after all the tests residing in a package.\nfunc TestMain(m *testing.M) { StartDatabase() code := m.Run() // go test will decide whether the tests failed or not by exit code os.Exit(code) Put everything together by modifying our tests:\nfunc Test_Product(t *testing.T) { t.Parallel() t.Run( \u0026#34;test create product\u0026#34;, func(t *testing.T) { t.Parallel() db := NewDatabase(t) repo := repository.NewProductPersistenceRepository(db) created, err := repo.Create( repository.Product{ Name: \u0026#34;cake\u0026#34;, Type: \u0026#34;food\u0026#34;, Code: \u0026#34;c1\u0026#34;, Price: 100, }, ) require.Nil(t, err) require.Equal(t, \u0026#34;cake\u0026#34;, created.Name) }, ) t.Run( \u0026#34;test get all products\u0026#34;, func(t *testing.T) { t.Parallel() db := NewDatabase(t) repo := repository.NewProductPersistenceRepository(db) _, err := repo.Create( repository.Product{ Name: \u0026#34;cake\u0026#34;, Type: \u0026#34;food\u0026#34;, Code: \u0026#34;c1\u0026#34;, Price: 100, }, ) require.Nil(t, err) products, err := repo.GetAll() require.Nil(t, err) require.Len(t, products, 1) }, ) t.Run( \u0026#34;test update product\u0026#34;, func(t *testing.T) { t.Parallel() db := NewDatabase(t) repo := repository.NewProductPersistenceRepository(db) created, err := repo.Create( repository.Product{ Name: \u0026#34;cake\u0026#34;, Type: \u0026#34;food\u0026#34;, Code: \u0026#34;c1\u0026#34;, Price: 100, }, ) require.Nil(t, err) created.Name = \u0026#34;new cake\u0026#34; updated, err := repo.Update(created) require.Nil(t, err) require.Equal(t, \u0026#34;new cake\u0026#34;, updated.Name) }, ) } We have learned how to use container for integration testing, and how to set up and execute test cases effectively. You can see the full code here\nReferences https://golang.testcontainers.org/ ","permalink":"https://duchoangmanh.github.io/posts/technical/testing-with-test-container-go/","summary":"The significance of integration testing in assuring the reliability and seamless operation of software systems cannot be understated. This guide will help you get started with using containers for integration testing and learn how to set up and execute test cases effectively.\nLet\u0026rsquo;s consider a small example program where I use postgres as the underlying database to store product records:\ncreate table product ( id serial8 not null primary key, name varchar(100) not null, type varchar(50) not null, code varchar(50) not null, price int4 not null ); The program can create, update and list products via a repository:","title":"How to write integration tests with test container in Go"},{"content":"Reflection trong Go Reflection trong go gi√∫p cho ta c√≥ th·ªÉ theo d√µi code t·∫°i th·ªùi ƒëi·ªÉm runtime, cho ph√©p ti·∫øp c·∫≠n m√£ ngu·ªìn ch∆∞∆°ng tr√¨nh d∆∞·ªõi d·∫°ng data c√≥ th·ªÉ x·ª≠ l√Ω thay v√¨ c√°c l·ªánh c√≥ th·ªÉ th·ª±c thi (m·ªôt nh√°nh trong metaprogramming).\nReflection trong go c√≥ th·ªÉ ƒë∆∞·ª£c th·ª±c hi·ªán th√¥ng qua reflect package. M·ªôt s·ªë kh·∫£ nƒÉng c·ªßa reflect:\nKi·ªÉm tra th√¥ng tin c·ªßa m·ªôt struct (s·ªë l∆∞·ª£ng method, s·ªë l∆∞·ª£ng field, ƒë·ªçc struct tag\u0026hellip;) m√† kh√¥ng c·∫ßn bi·∫øt tr∆∞·ªõc v·ªÅ struct ƒë√≥. Ki·ªÉm tra v√† c·∫≠p nh·∫≠t m·ªôt type (slice, channel, struct, interface, pointer\u0026hellip;) m√† kh√¥ng c·∫ßn bi·∫øt tr∆∞·ªõc v·ªÅ type ƒë√≥. ƒê·ªïi l·∫°i nh·ªØng kh·∫£ nƒÉng m·∫°nh m·∫Ω c·ªßa recflect, performance v√† t√≠nh maintainable c·ªßa code s·∫Ω gi·∫£m, c·∫ßn c√¢n nh·∫Øc kƒ© tr∆∞·ªõc khi quy·∫øt ƒë·ªãnh ƒë∆∞a v√†o ·ª©ng d·ª•ng.\nClear is better than clever. Reflection is never clear - Go proverb (Rob Pike)\n·ª®ng d·ª•ng c·ªßa reflect:\nC√°c function, method v·ªõi ƒë·∫ßu v√†o kh√¥ng r√µ tr∆∞·ªõc. Vi·∫øt c√¥ng c·ª• ph√¢n t√≠ch m√£ ngu·ªìn. Th·ª±c thi code linh ho·∫°t (VD li·ªát k√™ c√°c method c·ªßa m·ªôt struct v√† g·ªçi method theo t√™n). M·ªôt s·ªë package, library s·ª≠ d·ª•ng reflection: fmt, encoding/json, gorm, sqlx\u0026hellip;\nC√°c kh√°i ni·ªám quan tr·ªçng C√≥ hai type quan tr·ªçng trong reflect package: reflect.Type v√† reflect.Value, m·ªçi bi·∫øn trong m·ªôt ch∆∞∆°ng tr√¨nh c√≥ th·ªÉ ƒë∆∞·ª£c th·ªÉ hi·ªán b·ªüi m·ªôt c·∫∑p Value v√† Type. reflect.Type v√† reflect.Value nh∆∞ t√™n g·ªçi ch·ª©a c√°c th√¥ng tin t∆∞∆°ng ·ª©ng v·ªÅ type v√† value c·ªßa bi·∫øn ƒëang xem x√©t, ƒëi k√®m c√°c utilitiy funtion v√† method ƒë·ªÉ thao t√°c v·ªõi data. C√°c gi√° tr·ªã n√†y c·ªßa m·ªôt bi·∫øn x b·∫•t k√¨ c√≥ th·ªÉ ƒë∆∞·ª£c l·∫•y b·∫±ng reflect.ValueOf(x) v√† reflect.TypeOf(x):\ntype Person struct { Name string Age int } p := Person{ Name: \u0026#34;Duc\u0026#34;, Age: 10, } pp := \u0026amp;p o := []int{1, 2, 3} s := \u0026#34;reflect in go\u0026#34; fmt.Printf(\u0026#34;(%v, %v)\\n\u0026#34;, reflect.ValueOf(p), reflect.TypeOf(p)) fmt.Printf(\u0026#34;(%v, %v)\\n\u0026#34;, reflect.ValueOf(pp), reflect.TypeOf(pp)) fmt.Printf(\u0026#34;(%v, %v)\\n\u0026#34;, reflect.ValueOf(o), reflect.TypeOf(o)) fmt.Printf(\u0026#34;(%v, %v)\\n\u0026#34;, reflect.ValueOf(s), reflect.TypeOf(s)) K·∫øt qu·∫£:\n({Duc 10}, main.Person) (\u0026amp;{Duc 10}, *main.Person) ([1 2 3], []int) (reflect in go, string) Ngo√†i ra ta c≈©ng c√≥ th·ªÉ ƒë·ªçc ƒë∆∞·ª£c th√™m m·ªôt s·ªë th√¥ng tin quan tr·ªçng kh√°c nh∆∞ reflect.Kind - ch·ª©a th√¥ng tin c·ª• th·ªÉ h∆°n v·ªÅ ki·ªÉu c·ªßa m·ªôt bi·∫øn, c√≥ th·ªÉ truy c·∫≠p b·∫±ng Value.Kind() ho·∫∑c Type.Kind():\nfmt.Printf(\u0026#34;(%v, %v)\\n\u0026#34;, reflect.TypeOf(p), reflect.ValueOf(p).Kind()) fmt.Printf(\u0026#34;(%v, %v)\\n\u0026#34;, reflect.TypeOf(pp), reflect.ValueOf(pp).Kind()) fmt.Printf(\u0026#34;(%v, %v)\\n\u0026#34;, reflect.TypeOf(o), reflect.ValueOf(o).Kind()) fmt.Printf(\u0026#34;(%v, %v)\\n\u0026#34;, reflect.TypeOf(s), reflect.ValueOf(s).Kind()) K·∫øt qu·∫£:\n(main.Person, struct) (*main.Person, ptr) ([]int, slice) (string, string) Parse url query v·ªõi reflection X√©t b√†i to√°n c·∫ßn vi·∫øt m·ªôt h√†m nh·∫≠n v√†o m·ªôt *http.Request v√† m·ªôt struct sau ƒë√≥ fill d·ªØ li·ªáu t·ª´ URL query v√†o struct ƒë√≥:\ntype Person struct { Name string Age int } func ParseQuery(r *http.Request, p *Person) (err error) { q := r.URL.Query() p.Name = q.Get(\u0026#34;name\u0026#34;) p.Age, err = strconv.Atoi(q.Get(\u0026#34;age\u0026#34;)) return err } func TestParseQuery(t *testing.T) { req, _ := http.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;/root?name=Duc\u0026amp;age=10\u0026#34;, nil) var d Person err := Parse(req, \u0026amp;d) if err != nil { t.Error(err.Error()) } fmt.Println(d) // {Duc 10} } M·ªôt v√≠ d·ª• kh√° c∆° b·∫£n v√† th∆∞·ªùng g·∫∑p ph·∫£i kh√¥ng? Tuy nhi√™n c√°ch l√†m n√†y s·∫Ω c·∫ßn ph·∫£i l·∫∑p l·∫°i code kh√° nhi·ªÅu.\nV·∫≠y thay v√¨ bi·∫øt tr∆∞·ªõc struct ƒë∆∞·ª£c truy·ªÅn v√†o l√† Person th√¨ ta c√≥ th·ªÉ truy·ªÅn m·ªôt struct b·∫•t k√¨ v·ªõi c√°c field c√≥ t√™n ·ª©ng v·ªõi c√°c query c√≥ th·ªÉ g·∫∑p m√† v·∫´n ƒë·∫°t ƒë∆∞·ª£c k·∫øt qu·∫£ t∆∞∆°ng t·ª± hay kh√¥ng? V·ªõi reflect th√¨ ho√†n to√†n c√≥ th·ªÉ.\n√ù t∆∞·ªüng l√† c√≥ th·ªÉ d√πng reflect ƒë·ªÉ ƒë·ªçc th√¥ng tin c·ªßa struct b·∫•t k·ª≥ ƒë∆∞·ª£c truy·ªÅn v√†o, duy·ªát qua l·∫ßn l∆∞·ª£t c√°c field, v√† ki·ªÉm tra xem trong URL c√≥ query n√†o t∆∞∆°ng ·ª©ng v·ªõi field ƒëang x√©t hay kh√¥ng, n·∫øu c√≥ th√¨ ƒë·ªçc gi√° tr·ªã c·ªßa query v√†o field.\nB·∫Øt tay v√†o code T·ªïng quan c·ªßa ch∆∞∆°ng tr√¨nh c√≥ th·ªÉ ƒë∆∞·ª£c th·ªÉ hi·ªán nh∆∞ sau:\nfunc Parse(r *http.Request, dest any) (err error) { v := reflect.ValueOf(dest) q := r.URL.Query() if v.Kind() != reflect.Ptr || v.Elem().Kind() != reflect.Struct { return fmt.Errorf(\u0026#34;dest must be a pointer to a struct\u0026#34;) } v = v.Elem() t := v.Type() for i := 0; i \u0026lt; v.NumField(); i++ { fVal := v.Field(i) fType := t.Field(i) fName := strings.ToLower(fType.Name) err = parse(q.Get(fName), fVal) if err != nil { return fmt.Errorf(\u0026#34;parse %w\u0026#34;, err) } } return nil } func parse(stringVal string, destVal reflect.Value) (err error) { // x·ª≠ l√Ω c·ª• th·ªÉ cho t·ª´ng field } L∆∞u √Ω l√† b·∫Øt bu·ªôc ƒë·∫ßu v√†o c·ªßa h√†m ph·∫£i l√† m·ªôt con tr·ªè t·ªõi struct th√¨ reflect m·ªõi c√≥ th·ªÉ thay ƒë·ªïi ƒë∆∞·ª£c struct ƒë√≥, ta c√≥ th·ªÉ ki·ªÉm tra ƒëi·ªÅu ki·ªán n√†y v·ªõi v.Kind() == reflect.Ptr v√† v.Elem().Kind() == reflect.Struct - V√¨ ta expect gi√° tr·ªã truy·ªÅn v√†o l√† con tr·ªè (t∆∞∆°ng ·ª©ng reflect.Ptr n√™n c·∫ßn g·ªçi Elem() ƒë·ªÉ l·∫•y ra gi√° tr·ªã th·ª±c ·ªü sau con tr·ªè ƒë√≥) Sau khi ƒë√£ c√≥ ƒë∆∞·ª£c Type v√† Value c·ªßa struct ƒë·∫ßu v√†o r·ªìi, ta s·∫Ω ti·∫øn h√†nh duy·ªát qua t·ª´ng field v√† x·ª≠ l√Ω c·ª• th·ªÉ ·ªü trong h√†m parse\nfunc parse(stringVal string, destVal reflect.Value) (err error) { if stringVal == \u0026#34;\u0026#34; { // b·ªè qua n·∫øu nh∆∞ kh√¥ng c√≥ query t∆∞∆°ng ·ª©ng v·ªõi field n√†y return nil } if !destVal.CanSet() { return fmt.Errorf(\u0026#34;field unexported or cannot set value\u0026#34;) } k := destVal.Kind() switch { case k == reflect.String: err = parseString(stringVal, destVal) case k \u0026gt;= reflect.Int \u0026amp;\u0026amp; k \u0026lt;= reflect.Int64: err = parseInt(stringVal, destVal) default: err = fmt.Errorf(\u0026#34;type not supported: %v\u0026#34;, destVal.Type()) return err } Gi·∫£i th√≠ch: Trong h√†m n√†y ta s·∫Ω ki·ªÉm tra Kind c·ªßa t·ª´ng field v√† v·ªõi m·ªói kind ƒë√≥ s·∫Ω c√≥ h√†m c·ª• th·ªÉ ƒë·ªÉ x·ª≠ l√Ω gi√∫p cho code clear h∆°n. Trick nh·ªè l√† thay v√¨ ki·ªÉm tra v·ªõi t·ª´ng ki·ªÉu int, int8\u0026hellip; th√¨ c√≥ th·ªÉ vi·∫øt k \u0026gt;= reflect.Int \u0026amp;\u0026amp; k \u0026lt;= reflect.Int64 do trong m√£ ngu·ªìn c·ªßa reflect, c√°c Kind c√≥ th·ªÉ c√≥ c·ªßa bi·∫øn ƒë∆∞·ª£c vi·∫øt d∆∞·ªõi d·∫°ng:\nconst ( Invalid Kind = iota Bool Int Int8 Int16 Int32 Int64 ... ) T∆∞∆°ng t·ª± v·ªõi uint v√† float.\nL∆∞u √Ω quan tr·ªçng: reflect kh√¥ng th·ªÉ c·∫≠p nh·∫≠t unexported field, n√™n c·∫ßn ki·ªÉm tra tr∆∞·ªõc v·ªõi CanSet() (t∆∞∆°ng ·ª©ng v·ªõi CanAddr() == true v√† field exported). ho·∫∑c c√≥ th·ªÉ ki·ªÉm tra v·ªõi CanInterface()\nVi·∫øt h√†m parse ƒë·ªëi v·ªõi t·ª´ng Kind:\nfunc parseString(in string, dest reflect.Value) error { dest.SetString(in) return nil } func parseInt(in string, dest reflect.Value) error { intVal, err := strconv.ParseInt(in, 10, 0) if err != nil { return fmt.Errorf(\u0026#34;parseInt %w\u0026#34;, err) } dest.SetInt(intVal) return nil } Ti·∫øn h√†nh ch·∫°y th·ª≠ ch∆∞∆°ng tr√¨nh:\ntype Person struct { Name string Age int } func TestQueryParser(t *testing.T) { req, _ := http.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;/root?name=Duc\u0026amp;age=10\u0026#34;, nil) var d Person err := Parse(req, \u0026amp;d) if err != nil { t.Error(err.Error()) } fmt.Println(d) // {Duc 10} } It works!\nTh·∫ø c√≤n slice th√¨ sao? ƒê·∫ßu v√†o:\ntype Person struct { ... IDs []int } Expect v·ªõi URL query c√≥ d·∫°ng ?ids=1,2,3, sau khi parse th√¨ field IDs s·∫Ω c√≥ gi√° tr·ªã []int{1,2,3}.\nTh√™m case ƒë·ªëi v·ªõi Kind == reflect.Slice ·ªü h√†m parse\nfunc parse(stringVal string, destVal reflect.Value) (err error) { ... case k == reflect.Slice: err = parseSlice(stringVal, destVal) ... } func parseSlice(in string, dest reflect.Value) error { parts := strings.Split(in, \u0026#34;,\u0026#34;) sliceType := dest.Type().Elem() // l·∫•y type c·ªßa ph·∫ßn t·ª≠ strong slice sliceLen := len(parts) sliceVal := reflect.MakeSlice(reflect.SliceOf(sliceType), sliceLen, sliceLen) // make slice t∆∞∆°ng ·ª©ng for i := 0; i \u0026lt; sliceLen; i++ { // x·ª≠ l√Ω cho t·ª´ng ph·∫ßn t·ª≠ trong slice t∆∞∆°ng t·ª± nh∆∞ struct ·ªü tr√™n err := parse(parts[i], sliceVal.Index(i)) // parse t·ª´ng ph·∫ßn t·ª≠ trong slice nh∆∞ ƒë√£ l√†m v·ªõi int v√† string if err != nil { return fmt.Errorf(\u0026#34;parseSlice %w\u0026#34;, err) } } dest.Set(sliceVal) return nil } ƒê·ªÉ chuy·ªÉn t·ª´ URL query sang slice, ta c·∫ßn ki·ªÉm tra xem ·ªü struct ƒë√≠ch slice c√≥ ki·ªÉu d·ªØ li·ªáu g√¨ v√† make slice t∆∞∆°ng ·ª©ng, nh·ªØng c√¥ng vi·ªác sau ƒë√≥ kh√¥ng kh√°c g√¨ so v·ªõi x·ª≠ l√Ω struct ·ªü ph·∫ßn tr√™n.\nCh·∫°y th·ª≠ v·ªõi slice:\ntype Person struct { Name string Age int IDs []int } func TestQueryParser(t *testing.T) { req, _ := http.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;/root?ids=1,2,3\u0026#34;, nil) var d Person err := Parse(req, \u0026amp;d) if err != nil { t.Error(err.Error()) } fmt.Println(d.IDs) // [1 2 3] } Parse query linh ƒë·ªông v·ªõi struct tag ·ªû phi√™n b·∫£n hi·ªán t·∫°i, ch∆∞∆°ng tr√¨nh d·ª±a tr√™n t√™n c·ªßa c√°c field trong struct ƒë·ªÉ t·ª´ ƒë√≥ l·∫•y ra query t∆∞∆°ng ·ª©ng. ƒê·ªÉ ch∆∞∆°ng tr√¨nh ƒë∆∞·ª£c flexible h∆°n, c√≥ th·ªÉ d√πng struct tag ƒë·ªÉ ch·ªâ ƒë·ªãnh query t∆∞∆°ng ·ª©ng v·ªõi t·ª´ng field. V√≠ d·ª•\ntype Person struct { Name string `query:\u0026#34;title\u0026#34;` ... } V·ªõi s·ª± hi·ªán di·ªán c·ªßa tag query, field Name s·∫Ω ƒë∆∞·ª£c parse t·ª´ query title, c√°c field kh√¥ng c√≥ tag query th√¨ behavior v·∫´n kh√¥ng thay ƒë·ªïi.\nB·ªï sung th√™m ph·∫ßn ƒë·ªçc struct tag cho h√†m Parse:\nfunc Parse(r *http.Request, dest any) (err error) { v := reflect.ValueOf(dest) q := r.URL.Query() if !v.IsValid() || v.Kind() != reflect.Ptr || v.Elem().Kind() != reflect.Struct { return fmt.Errorf(\u0026#34;dest must be a pointer to not nil struct\u0026#34;) } v = v.Elem() t := v.Type() for i := 0; i \u0026lt; v.NumField(); i++ { fVal := v.Field(i) fType := t.Field(i) fName := strings.ToLower(fType.Name) if queryTag := fType.Tag.Get(\u0026#34;query\u0026#34;); queryTag != \u0026#34;\u0026#34; { // ki·ªÉm tra field c√≥ tag query hay kh√¥ng fName = queryTag } err = parse(q.Get(fName), fVal) if err != nil { return fmt.Errorf(\u0026#34;parse %w\u0026#34;, err) } } return nil } V√† ch·∫°y th·ª≠:\ntype Person struct { Name string `query:\u0026#34;title\u0026#34;` Age int IDs []int } func TestQueryParser(t *testing.T) { req, _ := http.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;/root?name=Duc\u0026amp;age=10\u0026amp;title=Gopher\u0026#34;, nil) var d Person err := Parse(req, \u0026amp;d) if err != nil { t.Error(err.Error()) } fmt.Println(d) // {Gopher 10 []} } Custom parse v·ªõi interface ƒê·∫øn phi√™n b·∫£n hi·ªán t·∫°i, parser ƒë√£ c√≥ th·ªÉ ƒë·∫°p ·ª©ng ƒë∆∞·ª£c c√°c ki·ªÅu d·ªØ li·ªáu c∆° b·∫£n trong ƒëa s·ªë tr∆∞·ªùng h·ª£p, nh∆∞ng ch∆∞a th·ªÉ ho·∫°t ƒë·ªông ƒë∆∞·ª£c v·ªõi c√°c ki·ªÉu d·ªØ li·ªáu t·ª± ƒë·ªãnh nghƒ©a. V√≠ d·ª• v·ªõi field Name, thay v√¨ ƒë∆°n thu·∫ßn l√† m·ªôt string, c√≥ th·ªÉ l√† struct d·∫°ng:\ntype Name struct { First string Last string } type Person struct { Name Name Age int IDs []int } Expect v·ªõi URL query c√≥ d·∫°ng ?name=duc_hoang th√¨ sau khi parse query, gi√° tr·ªã c·ªßa Person.Name s·∫Ω l√† Name{First:\u0026quot;duc\u0026quot;,Last:\u0026quot;hoang\u0026quot;}.\nM·ªôt l∆∞u √Ω khi vi·∫øt c√°c h√†m hay th∆∞ vi·ªán v·ªõi reflect, th√¨ n√™n h·∫°n ch·∫ø vi·ªác expose cho client ph·∫£i thao t√°c v·ªõi reflect ƒë·ªÉ ƒë∆°n gi·∫£n h√≥a vi·ªác s·ª≠ d·ª•ng h√†m hay th∆∞ vi·ªán ƒë√≥. Trong tr∆∞·ªùng h·ª£p n√†y, c√≥ th·ªÉ d√πng m·ªôt interface ƒë·ªÉ bi·ªÉu th·ªã ki·ªÉu d·ªØ li·ªáu t·ª± ƒë·ªãnh nghƒ©a c√≥ th·ªÉ parse ƒë∆∞·ª£c, khi Parse v√† field ƒë√≠ch implement interface n√†y th√¨ c√≥ th·ªÉ d√πng h√†m t∆∞∆°ng ·ª©ng ƒë·ªÉ x·ª≠ l√Ω field.\ntype QueryParser interface { QueryParse(string) error } Implement QueryParser interface cho ki·ªÉu Name:\nfunc (n *Name) QueryParse(in string) error { parts := strings.Split(in, \u0026#34;_\u0026#34;) if len(parts) != 2 { return fmt.Errorf(\u0026#34;invalid input\u0026#34;) } n.First = parts[0] n.Last = parts[1] return nil } L∆∞u √Ω l√† c·∫ßn implement ƒë·ªëi v·ªõi pointer receiver ƒë·ªÉ method c√≥ th·ªÉ thay ƒë·ªïi gi√° tr·ªã c·ªßa receiver.\nTi·∫øn h√†nh handle trong function parse:\nfunc parse(stringVal string, destVal reflect.Value) (err error) { ... default: err = parseDefault(stringVal, destVal) // chuy·ªÉn Kind m·∫∑c ƒë·ªãnh ra handle ri√™ng ƒë·ªÉ ƒë·∫£m b·∫£o code ƒë∆∞·ª£c clear v√† d·ªÖ maintain } return err } func parseDefault(in string, dest reflect.Value) error { if dest.Kind() != reflect.Ptr { dest = dest.Addr() // l·∫•y con tr·ªè c·ªßa dest n·∫øu dest ƒëang kh√¥ng ph·∫£i con tr·ªè } else if dest.IsNil() { dest.Set(reflect.New(dest.Type().Elem())) // kh·ªüi ta·ªç n·∫øu dest l√† con tr·ªè nil } if queryParser, ok := dest.Interface().(QueryParser); ok { return queryParser.QueryParse(in) // parser gi√° tr·ªã t·ª´ query v√†o dest } return fmt.Errorf(\u0026#34;type not supported: %s\u0026#34;, dest.Type().Kind()) } Trong h√†m parseDefault, gi√° tr·ªã ƒë√≠ch s·∫Ω lu√¥n ƒë∆∞·ª£c chuy·ªÉn sang ki·ªÉu con tr·ªè tr∆∞·ªõc khi x√°c ƒë·ªãnh xem n√≥ c√≥ implement QueryParser hay kh√¥ng.\nTrong tr∆∞·ªùng h·ª£p gi√° tr·ªã ƒë√≠ch ƒë√£ l√† con tr·ªè r·ªìi, c·∫ßn ki·ªÉm tra xem c√≥ ph·∫£i nil hay kh√¥ng, n·∫øu l√† nil th√¨ c·∫ßn ph·∫£i kh·ªüi t·∫°o tr∆∞·ªõc khi g·ªçi method.\nV√† ch·∫°y th·ª≠:\ntype Name struct { First string Last string } func (n *Name) QueryParse(in string) error { parts := strings.Split(in, \u0026#34;_\u0026#34;) if len(parts) != 2 { return fmt.Errorf(\u0026#34;invalid input\u0026#34;) } n.First = parts[0] n.Last = parts[1] return nil } type Person struct { Name Name Age int IDs []int } func TestQueryParser(t *testing.T) { req, _ := http.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;/root?name=duc_hoang\u0026#34;, nil) var d Person err := Parse(req, \u0026amp;d) if err != nil { t.Error(err.Error()) } fmt.Printf(\u0026#34;(%s, %s)\u0026#34;, d.Name.First, d.Name.Last) // (duc, hoang) } Source code trong b√†i: https://github.com/DucHoangManh/queryparser\n","permalink":"https://duchoangmanh.github.io/posts/technical/go-reflection-qua-vi-du/","summary":"Reflection trong Go Reflection trong go gi√∫p cho ta c√≥ th·ªÉ theo d√µi code t·∫°i th·ªùi ƒëi·ªÉm runtime, cho ph√©p ti·∫øp c·∫≠n m√£ ngu·ªìn ch∆∞∆°ng tr√¨nh d∆∞·ªõi d·∫°ng data c√≥ th·ªÉ x·ª≠ l√Ω thay v√¨ c√°c l·ªánh c√≥ th·ªÉ th·ª±c thi (m·ªôt nh√°nh trong metaprogramming).\nReflection trong go c√≥ th·ªÉ ƒë∆∞·ª£c th·ª±c hi·ªán th√¥ng qua reflect package. M·ªôt s·ªë kh·∫£ nƒÉng c·ªßa reflect:\nKi·ªÉm tra th√¥ng tin c·ªßa m·ªôt struct (s·ªë l∆∞·ª£ng method, s·ªë l∆∞·ª£ng field, ƒë·ªçc struct tag\u0026hellip;) m√† kh√¥ng c·∫ßn bi·∫øt tr∆∞·ªõc v·ªÅ struct ƒë√≥.","title":"Go: Gi·ªõi thi·ªáu v·ªÅ reflection qua v√≠ d·ª•"},{"content":"1. Ki·ªÉm tra s·ª± xu·∫•t hi·ªán c·ªßa m·ªôt ph·∫ßn t·ª≠ trong slice Type parameter hay generic l√† m·ªôt t√≠nh nƒÉng m·ªõi xu·∫•t hi·ªán t·ª´ phi√™n b·∫£n 1.18 c·ªßa Go. V·ªõi generic, ta c√≥ th·ªÉ vi·∫øt c√°c h√†m ho·∫∑c type c√≥ th·ªÉ d√πng ƒë∆∞·ª£c cho nhi·ªÅu ki·ªÉu d·ªØ li·ªáu ƒë·∫ßu v√†o kh√°c nhau m√† kh√¥ng c·∫ßn ph·∫£i l·∫∑p l·∫°i code nhi·ªÅu l·∫ßn.\nH√£y b·∫Øt ƒë·∫ßu v·ªõi m·ªôt v√≠ d·ª• ƒë∆°n gi·∫£n v√† ph·ªï bi·∫øn: Ki·ªÉm tra xem string c√≥ xu·∫•t hi·ªán trong slice hay kh√¥ng\nfunc StringSliceContains(ss []string, match string) bool { for _, s := range ss { if s == match { return true } } return false } R√µ r√†ng l√† trong qu√° tr√¨nh s·ª≠ d·ª•ng th·ª±c t·∫ø, ta s·∫Ω g·∫∑p c√°c usecase t∆∞∆°ng t·ª± v·ªõi c√°c ki·ªÉu d·ªØ li·ªáu kh√°c. Tr∆∞·ªõc khi c√≥ generic, vi·ªác ph·ªï bi·∫øn nh·∫•t s·∫Ω l√† vi·∫øt ri√™ng c√°c h√†m c·ª• th·ªÉ cho t·ª´ng ki·ªÉu d·ªØ li·ªáu IntSliceContains(), Int64SliceContains()\u0026hellip; b√™n c·∫°nh vi·ªác s·ª≠ d·ª•ng code generation hay reflection.\nC√≥ th·ªÉ th·∫•y c√°c h√†m n√†y ƒë·ªÅu l·∫∑p l·∫°i m·ªôt logic gi·ªëng nhau, ch·ªâ kh√°c ·ªü ki·ªÉu d·ªØ li·ªáu ƒë·∫ßu v√†o, v·ªõi generic, ta ho√†n to√†n c√≥ th·ªÉ r√∫t g·ªçn l·∫°i c√°c h√†m n√†y l·∫°i th√†nh m·ªôt, r·∫•t g·ªçn v√† d·ªÖ d√†ng b·∫£o tr√¨ v·ªÅ sau:\nfunc SliceContains[T comparable](ss []T, match T) bool { for _, s := range ss { if s == match { return true } } return false } Gi·∫£i th√≠ch:\n[T comparable] ƒë∆∞·ª£c g·ªçi l√† type parameter v√† c√≥ th·ªÉ s·ª≠ d·ª•ng ƒë∆∞·ª£c v·ªõi m·ªôt func ho·∫∑c m·ªôt type, trong tr∆∞·ªùng h·ª£p n√†y √°m ch·ªâ vi·ªác h√†m SliceContains c√≥ th·ªÉ nh·∫≠n v√†o ƒë·∫ßu v√†o ki·ªÉu T th·ªèa m√£n r√†ng bu·ªôc comparable.\nR√†ng bu·ªôc ·ªü ƒë√¢y l√† m·ªôt interface m√† T c·∫ßn th·ªèa m√£n, interface n√†y c√≥ th·ªÉ ch·ª©a method signature th∆∞·ªùng th·∫•y ho·∫∑c t·∫≠p h·ª£p c√°c type b·∫•t k√¨, xem th√™m package constraints.\nTa ho√†n to√†n c√≥ th·ªÉ ƒë·ªãnh nghƒ©a constraints c√πa ri√™ng m√¨nh.\ntype MyConstraint interface { ~int | ~string } func SliceContains[T MyConstraint](ss []T, match T) bool { for _, s := range ss { if s == match { return true } } return false } Nh∆∞ v√≠ d·ª• tr√™n ƒë√¢y, T c·∫ßn l√† int ho·∫∑c string, to√°n t·ª≠ ~ t·ª©c r√†ng bu·ªôc th·ªèa m√£n v·ªõi c·∫£ c√°c ki·ªÉu ƒë∆∞·ª£c ƒë·ªãnh nghƒ©a t·ª´ int ho·∫∑c string (v√≠ d·ª• type Name string, type Age int)\nfunc TestSliceContains(t *testing.T) { intSlice := []int{4, 5, 6} stringSlice := []string{\u0026#34;a\u0026#34;, \u0026#34;abb\u0026#34;, \u0026#34;c\u0026#34;} fmt.Println(SliceContains(intSlice, 5)) // true fmt.Println(SliceContains(stringSlice, \u0026#34;c\u0026#34;)) // true } C√≥ th·ªÉ th·∫•y l√† khi g·ªçi h√†m kh√¥ng c·∫ßn ch·ªâ r√µ ra T l√† ki·ªÉu g√¨ m√† ch·ªâ c·∫ßn truy·ªÅn c√°c parameter v√†o, go c√≥ th·ªÉ t·ª± hi·ªÉu v√† th·ª±c thi ƒë√∫ng h√†m m√† ta mong mu·ªën, SliceContains[int](intSlice, 5) c≈©ng t∆∞∆°ng ƒë∆∞∆°ng v·ªõi SliceContains(intSlice, 5).\nTa c≈©ng c√≥ th·ªÉ vi·∫øt m·ªôt h√†m ki·ªÉm tra ph·∫ßn t·ª≠ c√≥ thu·ªôc slice hay kh√¥ng m√† kh√¥ng c√≥ r√†ng bu·ªôc, thay v√†o ƒë√≥, truy·ªÅn v√†o m·ªôt funcion equalFunc ƒë·ªÉ s·ª≠ d·ª•ng thay cho to√°n t·ª≠ ==:\nfunc SliceContainsWithEqual[T any](ss []T, match T, equalFunc func(T, T) bool) bool { for _, s := range ss { if equalFunc(s, match) { return true } } return false } 2. Generic wrapper cho container/heap Trong go, khi c·∫ßn s·ª≠ d·ª•ng heap, ta c√≥ th·ªÉ s·ª≠ d·ª•ng package container/heap v√† implement heap.Interface cho ki·ªÉu d·ªØ li·ªáu mu·ªën s·ª≠ d·ª•ng.\nV√≠ d·ª• m·ªôt min heap cho ki·ªÉu int t·ª´ trong document c·ªßa container/heap:\ntype IntHeap []int func (h IntHeap) Len() int { return len(h) } func (h IntHeap) Less(i, j int) bool { return h[i] \u0026lt; h[j] } func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *IntHeap) Push(x any) { // Push and Pop use pointer receivers because they modify the slice\u0026#39;s length, // not just its contents. *h = append(*h, x.(int)) } func (h *IntHeap) Pop() any { old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x } Trong nhi·ªÅu tr∆∞·ªùng h·ª£p, ta ch·ªâ quan t√¢m t·ªõi ki·ªÉu d·ªØ li·ªáu v√† method Less, c√≤n c√°ch tri·ªÅn khai t∆∞∆°ng t·ª± nh∆∞ v√≠ d·ª• tr√™n.\nC√≥ th·ªÉ d√πng type parameter ƒë·ªÉ ƒë∆°n gi·∫£n h√≥a vi·ªác s·ª≠ d·ª•ng heap nh∆∞ sau:\ntype Heap[T any] struct { data []T lessFunc func(a, b T) bool } func (b *Heap[T]) Len() int { return len(b.data) } func (b *Heap[T]) Less(i, j int) bool { return b.lessFunc(b.data[i], b.data[j]) } func (b *Heap[T]) Swap(i, j int) { tmp := b.data[i] b.data[i] = b.data[j] b.data[j] = tmp } func (b *Heap[T]) Push(x any) { b.data = append(b.data, x.(T)) } func (b *Heap[T]) Pop() any { old := b.data oldLen := len(old) res := old[oldLen-1] b.data = b.data[:oldLen-1] return res } func New[T any](lessFunc func(T, T) bool) *Heap[T] { h := \u0026amp;Heap[T]{ lessFunc: lessFunc, } heap.Init(h) return h } Type parameter c≈©ng c√≥ th·ªÉ s·ª≠ d·ª•ng v·ªõi type nh∆∞ trong v√≠ d·ª• n√†y. M·∫•u ch·ªët trong c√°ch tri·ªÉn khai n√†y ch√≠nh l√† l∆∞u l·∫°i lessFunc trong struct Heap, do ta kh√¥ng th·ªÉ thay ƒë·ªïi method Less t·∫°i runtime, thay v√†o ƒë√≥ Less s·∫Ω g·ªçi v√†o h√†m ƒë∆∞·ª£c l∆∞u trong receiver.\nTuy nhi√™n c√≥ th·ªÉ th·∫•y r·∫±ng ki·ªÉu c·ªßa c√°c method nh∆∞ Push hay Pop l·∫°i l√† any v√† ƒë·ªÉ ƒë·∫£m b·∫£o implement heap.Interface, ta kh√¥ng th·ªÉ s·ª≠a signature c·ªßa c√°c method n√†y. Ngo√†i ra, vi·ªác g·ªçi tr·ª±c ti·∫øp *Heap.Pop thay v√¨ heap.Pop(*Heap), v√† *Heap.Push(T) thay v√¨ heap.Push(*Heap, T) s·∫Ω g√¢y ra k·∫øt qu·∫£ sai, thay v√†o ƒë√≥ n√™n tr√°nh cho ph√©p g·ªçi tr·ª±c ti·∫øp c√°c method n√†y. Ta s·∫Ω wrap type m√† implement heap interface trong m·ªôt public Type m√† s·∫Ω nh·∫≠n v√† tr·∫£ v·ªÅ k·∫øt qu·∫£ mong mu·ªën:\nChuy·ªÉn tri·ªÉn khai tr√™n th√†nh m·ªôt unexported struct v·ªõi t√™n base:\ntype base[T any] struct { data []T lessFunc func(a, b T) bool } func (b *base[T]) Len() int { return len(b.data) } func (b *base[T]) Less(i, j int) bool { return b.lessFunc(b.data[i], b.data[j]) } func (b *base[T]) Swap(i, j int) { tmp := b.data[i] b.data[i] = b.data[j] b.data[j] = tmp } func (b *base[T]) Push(x any) { b.data = append(b.data, x.(T)) } func (b *base[T]) Pop() any { old := b.data oldLen := len(old) res := old[oldLen-1] b.data = b.data[:oldLen-1] return res } V√† vi·∫øt th√™m m·ªôt genetic type v·ªõi c√°c method m√† ta mong mu·ªën:\ntype Heap[T any] struct { base *base[T] } func New[T any](lessFunc func(T, T) bool) *Heap[T] { b := \u0026amp;base[T]{ lessFunc: lessFunc, } heap.Init(b) return \u0026amp;Heap[T]{base: b} } func (h *Heap[T]) Push(t T) { heap.Push(h.base, t) } func (h *Heap[T]) Pop() T { if h.Len() == 0 { // th√™m validate cho Pop var t T return t } return heap.Pop(h.base).(T) // chuy·ªÉn ƒë·ªïi ki·ªÉu tr·∫£ v·ªÅ cho ƒë√∫ng } func (h *Heap[T]) Len() int { return h.base.Len() } Ch·∫°y th·ª≠:\nfunc TestGenericHeap(t *testing.T) { data := []int{0, 5, 4, 2, -5, 8, 9, -10} lessFunc := func(i, j int) bool { return j-i \u0026gt; 0 } heap := New(lessFunc) for _, v := range data { heap.Push(v) } for heap.Len() \u0026gt; 0 { fmt.Print(heap.Pop(), \u0026#34; \u0026#34;) } } K·∫øt qu·∫£:\n-10 -5 0 2 4 5 8 9 Clear h∆°n kh√° nhi·ªÅu ph·∫£i kh√¥ng? C√≥ th·ªÉ xem code ƒë·∫ßy ƒë·ªß t·∫°i ƒë√¢y\n3. Khi n√†o d√πng type parameter? Khi d√πng type parameter ch·ªâ ƒë·ªÉ g·ªçi method c·ªßa constraints th√¨ kh√¥ng n√™n d√πng type parameter m√† n√™n d√πng h√†m b√¨nh th∆∞·ªùng nh·∫≠n v√†o interface. thay v√¨ func foo[T io.Writer](w T) { ... w.Write... ... } t·ªët h∆°n l√†\nfunc foo(w io.Writer) { ... w.Write... ... } nh∆∞ c√°ch m√† n√≥ v·∫´n ƒë∆∞·ª£c vi·∫øt t·ª´ tr∆∞·ªõc khi go c√≥ generic.\nV√† trong nhi·ªÅu tr∆∞·ªùng h·ª£p, vi·ªác s·ª≠ d·ª•ng type parameter c√≥ th·ªÉ ·∫£nh h∆∞·ªüng nhi·ªÅu ƒë·∫øn t√≠nh d·ªÖ b·∫£o tr√¨ c·ªßa code, h√£y c√¢n nh·∫Øc s·ª≠ d·ª•ng c√°c ph∆∞∆°ng ph√°p kh√°c ƒë√£ n√™u ·ªü ph·∫ßn 1. H√£y nh·ªõ l√† go developer v·∫´n s·ªëng (kh√°) t·ªët trong m·ªôt th·ªùi gian d√†i m√† kh√¥ng c√≥ generic (‚óç‚Ä¢·¥ó‚Ä¢‚óç)üëç. ","permalink":"https://duchoangmanh.github.io/posts/technical/go-gioi-thieu-type-parameter-qua-vi-du/","summary":"1. Ki·ªÉm tra s·ª± xu·∫•t hi·ªán c·ªßa m·ªôt ph·∫ßn t·ª≠ trong slice Type parameter hay generic l√† m·ªôt t√≠nh nƒÉng m·ªõi xu·∫•t hi·ªán t·ª´ phi√™n b·∫£n 1.18 c·ªßa Go. V·ªõi generic, ta c√≥ th·ªÉ vi·∫øt c√°c h√†m ho·∫∑c type c√≥ th·ªÉ d√πng ƒë∆∞·ª£c cho nhi·ªÅu ki·ªÉu d·ªØ li·ªáu ƒë·∫ßu v√†o kh√°c nhau m√† kh√¥ng c·∫ßn ph·∫£i l·∫∑p l·∫°i code nhi·ªÅu l·∫ßn.\nH√£y b·∫Øt ƒë·∫ßu v·ªõi m·ªôt v√≠ d·ª• ƒë∆°n gi·∫£n v√† ph·ªï bi·∫øn: Ki·ªÉm tra xem string c√≥ xu·∫•t hi·ªán trong slice hay kh√¥ng","title":"Go: Gi·ªõi thi·ªáu v·ªÅ type parameter (generic) qua v√≠ d·ª•"},{"content":"Some Go tips (maybe some dark side too) and notes for writing better code.\n1. Efficiently converse between string and byte slice Gain some performance with the price of maintainability. Using the unsafe package is not advised but we can use it to efficiently converse between a string and byte slice. Use at your own risk.\nbyte slice to string func String(b []byte) (s string) { if len(b) == 0 { return \u0026#34;\u0026#34; } return *(*string)(unsafe.Pointer(\u0026amp;b)) } string to byte slice // mutate the returned slice can cause undefined behavior func ByteSlice(s string) []byte { var b []byte hdr := (*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;b)) hdr.Data = (*reflect.StringHeader)(unsafe.Pointer(\u0026amp;s)).Data hdr.Cap = len(s) hdr.Len = len(s) return b } 2. Change function return value with defer Normally, if we change the returned value with defer, it will not works\nfunc someFunc() int { i := 1 defer func() { i = 2 }() return i } func main() { fmt.Println(someFunc()) // 1 } But with a named return value, defer can change return value of a function\nfunc someFunc() (i int) { i = 1 defer func() { i = 2 }() return i } func main() { fmt.Println(someFunc()) // 2 } 3. Mutate a slice the right way Slice has a pointer to a backing array do not mean that it can be mutated by value\nLet\u0026rsquo;s look at the slice header from reflect package (a runtime representation of a slice but the idea is the same):\ntype SliceHeader struct { Data uintptr // pointer to the underlying array but can change when slice grows Len int // not safe for mutating via value Cap int // not safe for mutating via value } Don\u0026rsquo;t\nfunc main() { var s []int mutate(s) fmt.Println(s) // [] } func mutate(s []int) { s = append(s, 1) } Do\nfunc main() { var s []int mutate(\u0026amp;s) fmt.Println(s) // [1] } func mutate(s *[]int) { *s = append(*s, 1) } 4. Check if the any have desired method Sometimes we want to check if a variable of any type has some methods or not, consider using an anonymous interface\nimport \u0026#34;fmt\u0026#34; type Me int func (m Me) Pr() { fmt.Println(m) } func main() { var m any m = Me(1) if callable, ok := m.(interface { Pr() }); ok { // some action when the method exist } } If the interface is used more than once, better define a proper interface.\n5. Allocate memory for slices in advance We should use the third parameter when making a slice to allocate some memory for that slice to reduce slice grow.\nsomeSlice := make([]int, 0, size) And keep in mind that even if we use a slice with a part of an underlying array, the rest of that array may live in memory much longer than needed, consider copying to a new slice if necessary.\nPre-allocating can be used for maps too!\nsomeMap:= make(map[int]int, size) 6. Efficient String concatenation There\u0026rsquo;s some way to do string concatenation like use + or fmt package\nresult := \u0026#34;hello\u0026#34; + \u0026#34;world\u0026#34; // clean but remember that strings in go are immutable, so not very efficient result := fmt.Sprintf(\u0026#34;%s %s\u0026#34;, \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;) // use reflect under the hood Instead, consider strings.Builder\nvar b strings.Builder b.WriteString(\u0026#34;hello\u0026#34;) b.WriteString(\u0026#34;world\u0026#34;) result := b.String() In most cases, the difference can be neglected, but if we are doing heavy string concatenation like in a for loop, better use strings.Builder\n7. Channel special behaviors They are well known:\nA send to a nil channel blocks forever A receive from a nil channel blocks forever A send to a closed channel panics A receive from a closed channel returns the zero value immediately 8. Do not copy a sync type sync types shouldn‚Äôt be copied. This rule applies to:\nsync.Cond sync.Map sync.Mutex sync.RWMutex sync.Once sync.Pool sync.WaitGroup 9. io.Reader can only be read once Most type that implements the io.Reader interface (os.File, http.Request.Body...) behave like a stream and can only be read once. We can work around this with io.TeeReader that duplicate the stream, but in most case just avoid read an io.Reader a second time.\n10. Always close transient resource Remember to close transient resources to avoid memory leaks. Includes http.Response.Body, sql.Rows, os.File and more\n","permalink":"https://duchoangmanh.github.io/posts/technical/go-tips-and-optimization-notes/","summary":"Some Go tips (maybe some dark side too) and notes for writing better code.\n1. Efficiently converse between string and byte slice Gain some performance with the price of maintainability. Using the unsafe package is not advised but we can use it to efficiently converse between a string and byte slice. Use at your own risk.\nbyte slice to string func String(b []byte) (s string) { if len(b) == 0 { return \u0026#34;\u0026#34; } return *(*string)(unsafe.","title":"Go tips and optimization notes"},{"content":"This post contains my notes while implement caneweb - a gin-like minimal web framework/router after reading the first section of 7 days golang by geektutu (https://github.com/geektutu/7days-golang).\nHow standard net/http package handle request? First, let\u0026rsquo;s look at a sample written with net/http package:\nfunc main() { http.HandleFunc(\u0026#34;/\u0026#34;, handler) http.HandleFunc(\u0026#34;/post\u0026#34;, getAllPost) log.Fatal(http.ListenAndServe(\u0026#34;localhost:8000\u0026#34;, nil)) } func handler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;URL.Path = %q\\n\u0026#34;, r.URL.Path) } This piece of code binds two endpoints with the corresponding handler function, and starts a web server at port 8000, terminates the server if some errors are returned.\nAll http handlers must implement the handler interface, and we can use multiple handlers to handle a single request by passing the parameters around:\ntype Handler interface { ServeHTTP(ResponseWriter, *Request) } The standard library package does provide basic functions to create a web server including monitor port, static routing, request parsing\u0026hellip; Some other functions need to be implemented when necessary:\nDynamic routing: routing with rules like post/:id, post/*,\u0026hellip; or using regular expression. Middleware: By passing around the request, and response between multiple functions to change the result. Group requests: Group endpoints into a cluster that share some commons. Validate requests. \u0026hellip; Create the static-routing version of the framework First, we need to design a struct that represents the state of the current request data and have methods to easily work with requests.\nWhy encapsulate response and request into a single struct? Reduce the complexity of the handler, a user no longer need to care about which data resides in request, or responseWriter Easier to create a response and less error-prone, reduce repetitive For example, in order to write the response for a request, instead of\nobj = map[string]interface{}{ \u0026#34;title\u0026#34;: \u0026#34;my first blog post\u0026#34;, \u0026#34;read_time\u0026#34;: \u0026#34;5\u0026#34;, } w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) w.WriteHeader(http.StatusOK) encoder := json.NewEncoder(w) if err := encoder.Encode(obj); err != nil { http.Error(w, err.Error(), 500) } We can achive the same result in a simpler and clearer way:\nc.JSON(http.StatusOK, cane.Map{ \u0026#34;title\u0026#34;: \u0026#34;my first blog post\u0026#34;, \u0026#34;read_time\u0026#34;: 5, }) ctx.go\npackage cane import \u0026#34;net/http\u0026#34; type Ctx struct { // origin objects Writer http.ResponseWriter Req *http.Request // request data Path string Method string // response data StatusCode int } // newCtx create new Ctx with original data func newCtx(w http.ResponseWriter, r *http.Request) *Ctx { return \u0026amp;Ctx{ Writer: w, Req: r, Path: r.URL.Path, Method: r.Method, } } Add some functions to work with request and reponse morre efficiently:\n// responseWriter func (c *Ctx) SetHeader(key, value string) { c.Writer.Header().Set(key, value) } func (c *Ctx) Status(code int) { c.StatusCode = code c.Writer.WriteHeader(code) } func (c *Ctx) String(code int, formatString string, values ...interface{}) { c.SetHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/plain\u0026#34;) c.Status(code) _, err := fmt.Fprintf(c.Writer, formatString, values...) if err != nil { http.Error(c.Writer, err.Error(), http.StatusInternalServerError) } } func (c *Ctx) JSON(code int, data interface{}) { c.SetHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) c.Status(code) encoder := json.NewEncoder(c.Writer) err := encoder.Encode(data) if err != nil { http.Error(c.Writer, err.Error(), http.StatusInternalServerError) } } func (c *Ctx) HTML(code int, html string) { c.SetHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/html\u0026#34;) c.Status(code) _, err := c.Writer.Write([]byte(html)) if err != nil { http.Error(c.Writer, err.Error(), http.StatusInternalServerError) } } // request func (c *Ctx) FormValue(key string) string { return c.Req.FormValue(key) } func (c *Ctx) Query(key string) string { return c.Req.URL.Query().Get(key) } Our handler interface should look like this:\ntype Handler interface { Serve(c *Ctx) } Instead of creating a struct for each handler, we can use an adapter to use a function for a simple task, like in the standard net/http package:\ntype HandleFunc func(c *Ctx) func (f HandleFunc) Serve(c *Ctx) { f(c) } The static-routing router Now, we need an object to keep all our static routing configurations and decide which handler to use with each URL and method a.k.a router In this first version of the web framework, I simply use a map to represent the router with static routing:\nrouter.go\ntype router struct { handlers map[string]Handler } func newRouter() *router { return \u0026amp;router{ handlers: make(map[string]Handler), } } // create route from method and path func getRoute(method, path string) (route string) { var builder strings.Builder fmt.Fprintf(\u0026amp;builder, \u0026#34;%s%s%s\u0026#34;, method, \u0026#34;-\u0026#34;, path) route = builder.String() return } // add a new route to the router func (r *router) addRoute(method, path string, handler Handler) { log.Printf(\u0026#34;add route %s %s\u0026#34;, method, path) route := getRoute(method, path) r.handlers[route] = handler } //route request to appropriate handler, error code if no handler found func (r *router) handle(c *Ctx) { route := getRoute(c.Method, c.Path) if handler, ok := r.handlers[route]; ok { handler.Serve(c) } else { c.Writer.WriteHeader(http.StatusNotFound) c.String(http.StatusNotFound, \u0026#34;No route found\u0026#34;) } } Create the interface of caneweb Lastly, we need a layer for the user to work with the web framework, by hiding the internal implementation of the router and such.\ntype Engine struct { router *router } // constructor of cane web framework func New() *Engine { return \u0026amp;Engine{ router: newRouter(), } } func (e *Engine) addRoute(method, pattern string, handler Handler) { e.router.addRoute(method, pattern, handler) } // define some simple operations func (e *Engine) GET(pattern string, handler Handler) { e.addRoute(http.MethodGet, pattern, handler) } func (e *Engine) POST(pattern string, handler Handler) { e.addRoute(http.MethodPost, pattern, handler) } // implement the standard package Handler interface // and transform incoming request to our handler func (e *Engine) ServeHTTP(w http.ResponseWriter, r *http.Request) { ctx := newCtx(w, r) e.router.handle(ctx) } func (e *Engine) Run(addr string) error { return http.ListenAndServe(addr, e) } Create a simple server with the framework main.go\npackage main import ( \u0026#34;caneweb/cane\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { server := cane.New() server.GET(\u0026#34;/hello\u0026#34;, cane.HandleFunc(hello)) server.POST(\u0026#34;/post\u0026#34;, cane.HandleFunc(createPost)) log.Fatal(server.Run(\u0026#34;:5445\u0026#34;)) } func hello(c *cane.Ctx) { c.String(http.StatusOK, \u0026#34;hello %s\u0026#34;, c.Query(\u0026#34;name\u0026#34;)) } func createPost(c *cane.Ctx) { title := c.FormValue(\u0026#34;title\u0026#34;) desc := c.FormValue(\u0026#34;desc\u0026#34;) c.JSON(http.StatusOK, cane.Map{ \u0026#34;post_title\u0026#34;: title, \u0026#34;description\u0026#34;: desc, }) } Send requests to the web server with curl.\ncurl \u0026#34;127.0.0.1:5445/hello?name=duchm\u0026#34; hello duchm curl \u0026#34;http://localhost:5445/post\u0026#34; -X POST -d \u0026#39;title=\u0026#34;first post\u0026#34;\u0026amp;desc=\u0026#34;rainny day\u0026#34;\u0026#39; {\u0026#34;description\u0026#34;:\u0026#34;\\\u0026#34;rainny day\\\u0026#34;\u0026#34;,\u0026#34;post_title\u0026#34;:\u0026#34;\\\u0026#34;first post\\\u0026#34;\u0026#34;} curl \u0026#34;127.0.0.1:5445/any\u0026#34; No route found That\u0026rsquo;s it, after this, we have implemented the prototype version of caneweb framework in go. Currently, the framework does nothing more than the standard net/http package but worry not, some other nice features will be added in the next versions.\nSee the source code at https://github.com/DucHoangManh/caneweb\n","permalink":"https://duchoangmanh.github.io/posts/technical/create-a-web-framework-in-go/","summary":"This post contains my notes while implement caneweb - a gin-like minimal web framework/router after reading the first section of 7 days golang by geektutu (https://github.com/geektutu/7days-golang).\nHow standard net/http package handle request? First, let\u0026rsquo;s look at a sample written with net/http package:\nfunc main() { http.HandleFunc(\u0026#34;/\u0026#34;, handler) http.HandleFunc(\u0026#34;/post\u0026#34;, getAllPost) log.Fatal(http.ListenAndServe(\u0026#34;localhost:8000\u0026#34;, nil)) } func handler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;URL.Path = %q\\n\u0026#34;, r.URL.Path) } This piece of code binds two endpoints with the corresponding handler function, and starts a web server at port 8000, terminates the server if some errors are returned.","title":"Create a web framework in Go part 1: static routing"},{"content":"T·∫°i sao l·∫°i c√≥ b√†i vi·∫øt n√†y?: Design pattern: Nh·ªØng gi·∫£i ph√°p c√≥ th·ªÉ t√°i s·ª≠ d·ª•ng cho c√°c v·∫•n ƒë·ªÅ th∆∞·ªùng g·∫∑p t·∫°i m·ªôt ng·ªØ c·∫£nh nh·∫•t ƒë·ªãnh trong qu√° trinh thi·∫øt k·∫ø ph·∫ßn m·ªÅm.\nB√†i vi·∫øt n√†y n√≥i v·ªÅ m·ªôt s·ªë Design pattern \u0026ldquo;th√¢n thi·ªán\u0026rdquo; h∆°n trong go, ƒë∆∞·ª£c m√¨nh t·ªïng h·ª£p d·ª±a tr√™n bu·ªïi talk c·ªßa Ryan Djurovich (https://www.youtube.com/watch?v=HHqv3_rUr88) v√† m·ªôt s·ªë ngu·ªìn t√†i li·ªáu kh√°c m√† m√¨nh ƒë·ªçc ƒë∆∞·ª£c.\nFactory pattern Kh·ªèi ph·∫£i n√≥i v·ªÅ ƒë·ªô ph·ªï bi·∫øn c·ªßa n√≥ r·ªìi, r·∫•t h·ªØu √≠ch khi c·∫ßn ph·∫£i kh·ªüi t·∫°o m·ªôt ƒë·ªëi t∆∞·ª£ng c√≥ nhi·ªÅu tri·ªÉn khai (concrete types), ph√≠a client ch·ªâ c·∫ßn quan t√¢m ƒë·∫øn c√°c method, Factory s·∫Ω lo vi·ªác l·ª±a ch·ªçn tri·ªÉn khai n√†o s·∫Ω ƒë∆∞·ª£c d√πng ƒë·ªÉ x·ª≠ l√Ω d·ªØ li·ªáu.\n// use Stringer as the interface type ErrPrint struct{} func (p *ErrPrint) String() string { return \u0026#34;some error happens\u0026#34; } type InfoPrint struct{} func (p *InfoPrint) String() string { return \u0026#34;nothing dramatically happens\u0026#34; } func NewPrinter(kind string) (result fmt.Stringer, err error) { switch kind { case \u0026#34;error\u0026#34;: result = \u0026amp;ErrPrint{} case \u0026#34;info\u0026#34;: result = \u0026amp;InfoPrint{} default: err = errors.New(\u0026#34;invalid kind\u0026#34;) } return } Decorator (Functional option) ƒê·ªÉ n√≥i v·ªÅ pattern n√†y, ƒë·∫ßu ti√™n h√£y xem v√≠ d·ª• b√™n d∆∞·ªõi:\nfunc runServer() { http.HandleFunc(\u0026#34;/\u0026#34;, helloEndpoint) log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil)) } func helloEndpoint(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;Hello world\u0026#34;) } ƒêo·∫°n code tr√™n t·∫°o ra m·ªôt web server ƒë∆°n gi·∫£n v·ªõi net/http package v·ªõi m·ªôt endpoint duy nh·∫•t. B√†i to√°n ƒë∆∞·ª£c ƒë·∫∑t ra l√† b√¢y gi·ªù c·∫ßn log l·∫°i th·ªùi gian c·∫ßn ƒë·ªÉ ho√†n t·∫•t x·ª≠ l√Ω request. ƒê·ªÉ gia tƒÉng t√≠nh t√°i s·ª≠ d·ª•ng, tr√°nh ph·∫£i s·ª≠a l·∫°i handler, c≈©ng nh∆∞ d·ªÖ d√†ng b·∫£o tr√¨ v·ªÅ sau, ta c√≥ th·ªÉ vi·∫øt nh∆∞ sau:\nfunc runServer() { http.HandleFunc(\u0026#34;/\u0026#34;, durationLogger(helloEndpoint)) log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil)) } func helloEndpoint(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, \u0026#34;Hello world\u0026#34;) } func durationLogger(f http.HandlerFunc) http.HandlerFunc { return func(writer http.ResponseWriter, request *http.Request) { startTime := time.Now() f(writer, request) log.Printf(\u0026#34;complete handle request after %s ms\u0026#34;, time.Since(startTime).Milliseconds()) } } Nh∆∞ v·∫≠y, ch√∫ng ta c√≥ th·ªÉ d·ªÖ d√†ng th√™m t√≠nh nƒÉng log th·ªùi gian n√†y v√†o nh·ªØng handler c·∫ßn thi·∫øt, vi·ªác thay ƒë·ªïi n·ªôi dung log c≈©ng tr·ªü n√™n d·ªÖ d√†ng h∆°n. ƒê√¢y ch·ªâ l√† m·ªôt v√≠ d·ª• ƒë∆°n gi·∫£n v·ªÅ middleware, trong th·ª±c t·∫ø vi·ªác tri·ªÉn khai c√≥ th·ªÉ ph·ª©c t·∫°p h∆°n ƒë·ªÉ ph√π h·ª£p v·ªõi c√°c nh√π c·∫ßu kh√°c nhau.\nIterator T·∫°i sao l·∫°i c·∫ßn pattern n√†y thay v√¨ duy·ªát (array, slice, map, channel\u0026hellip;) trong go?\nC√≥ th·ªÉ k·∫øt h·ª£p v·ªõi decorator Khi vi·∫øt m·ªôt module n√†o ƒë√≥ m√† mu·ªën che gi·∫•u tri·ªÉn khai b√™n d∆∞·ªõi, ch·ªâ cho ph√©p ph√≠a s·ª≠ d·ª•ng duy·ªát tu·∫ßn t·ª± c√°c ph·∫ßn t·ª≠. V√≠ d·ª• io.Reader, sql/database.Row type Iterator struct { tasks []string position int } // Next will return the next task in the slice // if there\u0026#39;s more data to iterate, more will be true func (t *Iterator) Next() (pos int, val string, more bool) { t.position++ if t.position \u0026gt; len(t.tasks) { return t.position, \u0026#34;\u0026#34;, false } return t.position, t.tasks[t.position-1], true } Tr√™n ƒë√¢y l√† m·ªôt v√≠ d·ª• ƒë∆°n gi·∫£n v·ªÅ tri·ªÉn khai iterator trong go\nfor _, val, more := i.Next(); more; _, val, more = i.Next() { fmt.Println(val) } Dependency Injection DI trong go c√≥ th·ªÉ ƒë∆∞·ª£c tri·ªÉn khai theo nhi·ªÅu c√°ch, c√≥ c·∫£ nh·ªØng th∆∞ vi·ªán chuy√™n d√πng ƒë·ªÉ DI trong go (google/wire, uber-go/fx), trong b√†i vi·∫øt n√†y s·∫Ω ch·ªâ n√≥i v·ªÉ c√°ch tri·ªÉn khai ƒë∆°n gi·∫£n nh·∫•t\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ Client package ‚îÇ Client ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ Client Service Interface ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ≤‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ|‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚î§ ‚îÇ Service package ‚îÇ Concrete Service 1 ‚îÇ ‚îÇConcrete Service 2‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ƒê√¢y l√† m·ªôt ƒëo·∫°n code v√≠ d·ª• co dependency injection s·ª≠ d·ª•ng constructor\nfunc main() { s := NewMyService(os.Stderr) s.WriteHello(\u0026#34;world\u0026#34;) } type MyService struct { writer io.Writer } func NewMyService(writer io.Writer) MyService { return MyService{ writer: writer, } } func (s *MyService) WriteHello(m string) { fmt.Fprintf(s.writer, \u0026#34;Hello %s\\n\u0026#34;, m) } Th√™m method ƒë·ªÉ c√≥ th·ªÉ s·ª≠ d·ª•ng setter injection:\nfunc (s *MyService) SetWriter(w io.Writer) { s.writer = w } So s√°nh hai c√°ch:\nconstructor: ƒê·∫£m b·∫£o dependency ƒë∆∞·ª£c s·ª≠ d·ª•ng lu√¥n valid setter: C√≥ th·ªÉ thay th·∫ø concrete service trong qu√° tr√¨nh ch·∫°y ch∆∞∆°ng tr√¨nh(runtime) Repository M·ªôt pattern trong thi·∫øt k·∫ø ph·∫ßn m·∫øm h∆∞·ªõng t·ªõi vi·ªác ti·∫øn h√≥a l√¢u d√†i c·ªßa ·ª©ng d·ª•ng, c√°c module ph·ª• thu·ªôc c√≥ th·ªÉ ƒë∆∞·ª£c thay ƒë·ªïi trong t∆∞∆°ng lai. V√≠ d·ª• d∆∞·ªõi ƒë·ªÅ th·ªÉ hi·ªán vi·ªác tri·ªÉn khai m·ªôt ·ª©ng d·ª•ng m√† l·ªõp storage c√≥ th·ªÉ ƒë∆∞·ª£c thay ƒë·ªïi: package post - khai b√°o model\ntype Post struct { ID int64 Title string } package domain - khai b√°o c√°c interface client s·ª≠ d·ª•ng ƒë·ªÉ thao t√°c v·ªõi storage\n// Repository must be implemented by all implementations of Post storage type Repository interface { FindAll() ([]post.Post, error) Store(post post.Post) (post.Post, error) DeleteById(postId int64) error } package memstorage - m·ªôt tri·ªÉn khai c·ªßa storage\n//in-memory implementation type PostStorage struct { posts map[int64]string highestID int64 } func (p *PostStorage) FindAll() ([]post.Post, error) { result := make([]post.Post, 0) for id, title := range p.posts { result = append(result, post.Post{ ID: id, Title: title, }) } return result, nil } func (p *PostStorage) Store(post post.Post) (post.Post, error) { if p.posts == nil { p.posts = make(map[int64]string) } if post.ID \u0026lt;= 0 { p.highestID++ post.ID = p.highestID } else { if _, exists := p.posts[post.ID]; !exists { return post, fmt.Errorf(\u0026#34;post already exist\u0026#34;) } } p.posts[post.ID] = post.Title return post, nil } func (p *PostStorage) DeleteById(postId int64) error { delete(p.posts, postId) return nil } S·ª≠ d·ª•ng repository package: package main\nfunc main() { postRepo := memstorage.PostStorage{} //may change to other implementation in the future newPost, err := postRepo.Store(post.Post{ Title: \u0026#34;Eagles fly\u0026#34;, }) if err != nil { log.Println(\u0026#34;can not create post\u0026#34;, err) } else { log.Printf(\u0026#34;created post with id %d\u0026#34;, newPost.ID) } posts, err := postRepo.FindAll() if err != nil { log.Println(\u0026#34;can not fetch posts\u0026#34;, err) } else { log.Println(posts) } } B·∫±ng c√°ch chia nh·ªè vi·ªác tri·ªÉn khai, domain interface v√† model, trong tr∆∞·ªùng h·ª£p m·ªôt ph·∫ßn m·ªÅm c·∫ßn thay th·∫ø c√°c module trong t∆∞∆°ng lai, c√≥ th·ªÉ update m·ªôt c√°ch d·ªÖ d√†ng.\nM√£ ngu·ªìn trong b√†i vi·∫øt c√≥ th·ªÉ xem t·∫°i: https://github.com/DucHoangManh/go-patterns\n","permalink":"https://duchoangmanh.github.io/posts/technical/design-pattern-than-thien-trong-go/","summary":"T·∫°i sao l·∫°i c√≥ b√†i vi·∫øt n√†y?: Design pattern: Nh·ªØng gi·∫£i ph√°p c√≥ th·ªÉ t√°i s·ª≠ d·ª•ng cho c√°c v·∫•n ƒë·ªÅ th∆∞·ªùng g·∫∑p t·∫°i m·ªôt ng·ªØ c·∫£nh nh·∫•t ƒë·ªãnh trong qu√° trinh thi·∫øt k·∫ø ph·∫ßn m·ªÅm.\nB√†i vi·∫øt n√†y n√≥i v·ªÅ m·ªôt s·ªë Design pattern \u0026ldquo;th√¢n thi·ªán\u0026rdquo; h∆°n trong go, ƒë∆∞·ª£c m√¨nh t·ªïng h·ª£p d·ª±a tr√™n bu·ªïi talk c·ªßa Ryan Djurovich (https://www.youtube.com/watch?v=HHqv3_rUr88) v√† m·ªôt s·ªë ngu·ªìn t√†i li·ªáu kh√°c m√† m√¨nh ƒë·ªçc ƒë∆∞·ª£c.","title":"Design pattern th√¢n thi·ªán trong go"}]